# Computer_structure
2021 1학기 컴퓨터구조론 내용정리

CHPT 4

=======================
4A - Single Cycle

Control 유닛의 변수들
 
Reg Dst : 0 일 경우, imm 을 사용하는 명령어이고, 1 일 경우 R 을 사용하는 명령어이다.
ㄴ> 연산의 데스티네이션을 어디로 보낼 지 결정하는 변수라고 하겠다.

Reg Write : Write data 란의 항목이, Write Register 레지스터에 입력된다.
ㄴ> R 타이프일때 1 이 된다고 할 수 있는 것일까?

ALU Src : 1 일 경우, ALU 의 두번째 란에 들어갈 값을 imm 영역에서 가져온다. 즉 I 계통 명령어라는 뜻.
ㄴ> 반대로, 0 일 경우 ALU 의 두번째 란에 들어갈 값을 정상적으로 rt 란에서 가져온다고 하겠다.

PC Src : 1 일 경우, branch 명령어를 수행하겠다는 것으로 간주한다.
ㄴ> 0 일 경우, 일반적인 방법으로 PC = PC + 4 한다.
ㄴ> 만약 beq 의 조건이 만족되는 경우, 즉 ALU 

MemRead : load 명령어.
MemWrite : save 명령어. 

MemtoReg : 0 일 때 Save, 1 일때 Load 계통이다.

======================
4B - MultiCycle

새로운 Control 변수들

ALUSrc A : 0 일 경우 PC 를 Input 으로 받는다.
ALUSrc B : 총 4가지 Case 가 있다.

- 일반적인 R 타이프 명렁어
- 일반적인 I 타이프 명령어
- PC +4 를 계산하기 위해 B = 4 를 받는 Case
- Branch 를 위해 Shift 2 된 imm 을 받는 Case


PCSrc : 총 3가지 Case 가 있다.
- PC +4 (일반적 케이스)
- ALU Out 의 결과물로 점프하는 Case
- Jump 의 Target Address 로 점프하는 Case

ALUOP : 3가지 케이스가 있다.

- Funct 의 코드를 따르는 일반적 경우
- Add 와 Sub 두가지 Case


lorD : 0 이면 PC 가 매모리 유닛으로의 주소를 저장한다. 1이면 ALUOut 이 저장한다.

IRWrite : 1이면 IR 의 주소로 데이터가 Write 된다.



Multicycle - 메카니즘

싱글사이클 이상의 명령어 체계는 총 5가지로 명령어를 세분한다. 그리고 이 세분된 덩어리 하나당 1 사이클을 차지한다.

Instruction Fetch : 명령어 메모리 IM 으로부터 명령어를 가져온다.
Instruction Decode : 명령어가 디코드되어 Register File 영역으로 옮거진다. 
Execution : 받은 컨트롤 변수들에 의해 ALU 가 적절히 동작하여 값을 여기저기에 전달한다.
Memory Acess : 메모리 영역에 값을 읽거나 쓴다.
Memory read Completion : 레지스터 영역에 값을 읽거나 쓴다.


- 총 5가지 단계이다.
- R 타입은 총 4단계까지 진행하면 종료다.
- load 는 5단계, store 는 4단계까지 필요하다.
- Branch 의 경우 3단계에서 종료로 가장 짧다 (SLL 된 값이, ALU 의 동작 타이밍에 ADD 를 거치면서 PC 를 업데이트시킨다.)
- jump 의 경우도 마찬가지


이때, 멀티사이클의 1사이클 타임은 어떻게 결정되는가?
=> 5가지의 Instruction Block 들 중에서 레이턴시가 가장 큰, 즉 가장 느린 블록의 수행시간을 1사이클 타임으로 잡는다.

멀티사이클의 FSM - Moore Machine

- 상술한 컨트롤 변수들은, State Machine 라는 것을 사용하여 기술된다.
- 각 State 들은 Instruction Block 들을 더욱 세분한 것이며, 각 스테이지마다 Control 변수들이 조정된다.
- 그리고 각 State 들은 알맞은 다음 Stage 로 이동한다. 스테이지 내부의 컨트롤 변수들은 이 흐름을 조정하는 역할을 하기도 한다.


- 더 쪼개짐으로 인해서, 가장 길게 걸리는 Instruction 을 기준으로 설정되었던 Cycle Time 으로 인한 Waste 를 없엘 수 있다.


예외사항 : 오류가 발생하였을 때 대처하는 로직이 존재하고, 이것은 FSM 의 새로운 State 로 기록된다.

- EPC : PC - 4 를 기록한다.
- PC = 8000 0180

========================
파이프라인 - 원리

- 앞서 멀티사이클에서, 명령어의 실행을 총 5가지 스테이지로 나눴다.
- 그리고 프로세서의 물리적인 구조 역시, 이 5가지의 스테이지를 공장 생산라인을 거치듯이 구성하였었다.

- 그렇다면, 이 5개의 생산 벨트를 동시에 돌릴 수는 없을까? 
- 그렇게 되면, 총 5개의 스테이지가 1사이클마다 전부 동작하니, 1사이클 당 1개의 명령어가 실행되는 효과를 볼 수 있다.
ㄴ> 한번에 5개 이상이 동작하면 어떤 스테이지는 한번에 두개의 명령어를 처리해야 되기 때문에 논리적으로 불가능하다.
ㄴ> 총 5개의 명령어만 한번에 동작 가능한 것은 이러한 이유에서이다.

- 각 모듈들을 서로 독립시키기 위해서 (데이터가 유실되지 않게 하기 위해서), 모듈 사이사이에 레지스터가 존재한다.


Pipeline - Hazards

- 당연히 이러한 방식에는 문제가 생길 여지가 있다.

- 만약, 어떤 한 레지스터에 읽고 쓰는 명령어 두개가 연속으로 놓여 있다고 하자.
- 그렇다면, 레지스터에 새로운 값을 쓰기도 전에 그 다음 명령어가 읽어 버린다면 어떤 일이 발생할까?
- 당연히 개발자가 유도하지 않은 방향으로 프로그램이 동작하게 될 것이다. 이것을 해저드라고 하기로 했다.

- 발생 가능한 해저드의 상황은 어느정도 예상될 수 있다. 
- 해저드가 예상 되었다면, 단순히 쓰기 작업이 끝날 떄 까지 읽기 명렁어가 기다리게 할 수 있다. 


Hazard - 구조적 해저드

- 어떤 sw 명령으로 메모리에 값을 쓴다고 하자.
- store 과정이 완료되기 전에 load 명령어가 해당 메모리에서 값을 가져다 쓰려고 한다면 곤란한 상황이 발생할 것이다.
- 레지스터에도 마찬가지. 

- 이것은, 읽기를 쓰기보다 느리게 하는 것으로 어느정도 문제의 발생 확률을 낮출 수 있다.
- 쓰기는 갱신이다. 읽기는 가능한 늦게 읽을수록, 더 최신화된, 즉 더 알맞게 갱신된 값을 읽을수 있도록 한다. 당연한 이야기다.

Hazard - 의존성 해저드

최신화된 데이터는 항상 W 에서 발생한다. 

- RAW 상황 : Read After Write. R 이 맨 앞글자이지만 사실 R 이 뒤에 실행되는 것이 문제임을 지적하는 것이다.
ㄴ> 사실상 가장 의미있는 의존성 해저드이다.

- WAW 상황 : 앞선 Write 가 마쳐지기도 전에 그 다음의 Write 명령어가 실행되고 있는 상황이다.
- WAR 상황 : R 가 끝마쳐지기 전에 W 가 실행되는 상황.
ㄴ> 이 두가지 상황은 사실 해저드로 치지 않는다고 봐도 무방하다. 


의존성 해저드의 해결 - Stalling

- Stalling 은 기다린다는 뜻이다.
- 우리는 앞서, 읽기를 더 늦게, 쓰기를 더 빠르게 하도록 하였다.
- 따라서, 최신화를 하는 쓰기와 그것을 읽는 읽기가, 최소한 같은 싸이클에 동작해야 한다.
- RAW Hazard 는 그리하여 2사이클을 손해보게 만든다.

ex) Stalling 으로 인한 새로운 CPI 계산

- 만약 40퍼센트의 명령어가 Stalling 을 발생시킨다고 해 보자.
- 발생 시동 명령어의 CPI 를 생각해 보자. 

한참 제대로 작동중인 파이프라인은 원래 1 의 CPI 를 가지도록 되어 있다.
그런데 여기에, stalling 으로 인해서 2개의 사이클을 손해를 보고 말았다. 이것은 오롯이 시동 명령의 책임이다.

그렇다면 새로운 CPI 는, 기존에 내던 성적인 1 에다가 2 사이클을 추가로 더해야 한다는 말이다.
이러한 명령어가 총 40퍼센트나 된다.

=> 그렇다면, 총 CPI 는 1 + 0.4 *2 = 1.8 되시겠다.


의존성 해저드의 해결 - Forwarding

- ALU 에서 값이 최종적으로 산출되는 단계는 3단계의 말미이다.
- 레지스터에 Write 가 일어나는 단계는 5단계의 선미이다.

- ALU 에서 산출된 값을, 어디다 담아놨다가, Write 과정이 완료되기 전에 미리 쏴줄 수 없을까

- 레지스터를 사용하는 연산의 경우, 앞의 2 사이클 쉬어가는 것 막을 수 있다.

- lw 명령어의 경우, 레지스터가 갱신되는 타이밍이 빨라야 4단계의 말미이다. ( 쓰기는 읽기에 우선하므로 )
- 따라서, 해당 메모리의 값을 늦게 받아도 3단계의 ALU 에서 받아야 하는데, 여전히 1사이클은 쉬어줘야 한다. 


Control Hazard

- Branch 명령어가 있다고 하자. 4단계 전반에 가서야 PC 가 업데이트 된다고 한다. ( 3단계가 아닌가 싶지만 PC 에 값을 쓰는 거니까..4단계 전반)
- 그런데, 4단계가 실행되기 전에, 이미 1단계에서 업데이트된 PC +4 에 따라서 프로그램이 계속 실행되면?
- 심각한 문제다. 

Control Hazard 의 해결

- Stall : 4단계까지 기다려야 한다. 4사이클 손해
- Predict - Not taken : 그냥 명령문을 실행하되 그 결과를 리셋시켜버린다
- Predict - Taken : 명령문을 실행하고, 결과물을 올바른 위치로 다시 전달하기까지 한다. 
ㄴ> 많은 경우 Predict 방법이 쓰인다.




파이프라인과 컨트롤 변수들

- 컨트롤 변수들이 1사이클마다 ID 단계에서 업데이트 된다면 혼란이 발생할 것이다.
- 별 문제 없다. 레지스터와 메모리에 사용될 데이터들과 함께 컨트롤 변수를 파이프라인을 따라 이동시키면 문제 없다.
- 각 컨트롤 Signal 들은 사용되는 단계가 제각각이다. ID 에서 생성된 뒤 마지막 Reg 단계에서 사용되는 경우도 있다.


==================CHPT 5====================



////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////여기부턴 문제풀이 영역에서 훔쳐본 것들///////////////////////////\
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
Logic Blocks : I-MEM, Add, Mux, ALU, Regs, D-Mem, Sign-Extend, Shift-Left-2

ㄴ>Cycle Time 을 위 Logic Block 들이 사용되는 Path 를 바탕으로 알아야 한다.

4.1
Instruction Fetch : PC = PC+4 , IR = Memory[PC} 2가지의 LB 가 필요하다.

ㄴ>이들은 I-MEM, Add 위 두개의 Logic Block 들을 필요로 한다.
ㄴ>특이사항으로, PC 메모리에서 Load 하고 +4 하여 Feedback 하는 과정은 동시에 일어난다.

ㄴ>따라서 이 둘 중 에서 더 오래 걸리는 I-MEM 의 레이턴시가 Cycle Time 이 된다.


4.2
Unconditional Branch 명령어 : MIPS 의 "b" 명령어. I-MEM, Sign-Ext, SLL, ADD, MUX 총 5가지의 LB 가 필요하다.

ㄴ> 이번엔 이들의 레이턴시를 선형적으로 모두 더한다.
ㄴ> 이 문제에 나온 경우는 특히 Unconditional 이다. bne 의 경우처럼 Regs, ALU 등을 사용할 이유가 없다.
ㄴ> 그래서 imm 영역의 데이터를 가공하는 Sign-Ext, SLL 등만 사용한다. 

ㄴ> 4.1 에서는 프로세서의 Cycle Time 을 봤던 것이기 때문에, LB 중에 가장 긴 레이턴시를 가진 I-MEM 의 200 ps 가 선정된다.
ㄴ> 4.2 에서는, Data Path 의 총 레이턴시를 물어보고 있기 때문에 필요한 모든 LB 들의 레이턴시를 선형적으로 더하게 된다.

4.3
Conditional Branch 명령어 : MIPS 의 "beq" 명령어. I-MEM, Reg(+Sign Ext.), Mux(+SLL), ALU(+Add), Mux 총 5가지의 LB 가 필요하다.

ㄴ> 괄호 안의 동작들은 동시에 동작하는 LB 들이다. 다만 이들은 괄호 밖의 더 빠른 동작들에 잡아먹혀(마치 4.1 의 Add LB 처럼) 드러나지 않는 것이다.
ㄴ> Conditional Path 이기 때문에, Reg, Mux, ALU 로 통하는 조건식 비교연산이 수행되어야 하기 때문에, Cycle Time 이 더 길다.



4.4, 4.5 & 4.6 : sll 에 대하여 

4.4 : 위 LB 들의 정보들은 어떤 종류의 Instruction 들이 필요로 할까 : 정답은 PC-Relative Branches
4.5 : 어떤 Instruction 들이 위의 LB 들을 Critical Path 로 사용하는가? : PC-Relative, Unconditional Branches
ㄴ> MIPS 의 오리지널 명령으들의 경우 
4.6 : Conditional 과 Unconditional 의 비교이다. "b" 와 다르게 "beq" 만 사용하는 경우 105 가 더 길어지는 상황을 이야기하고 있다.


5.

5.1 : Data Memory 를 사용하는 명령어의 비율만 뽑아보라는 문제. Lw 와 Sw 의 비율을 더하면 된다.
5.2 : Sign-Extend LB 에 대한 이야기
ㄴ> I-Type 의 제시된 명령어들 - addi, LW, SW, BEQ 이들은 모두 I-Type 이기 때문에 Sign-Ext. 사용한다.
ㄴ> 다만, 해당 LB 가 필요하지 않더라도, 계산은 항상 이루어지고 있다. 다만 MUX 를 통해 이 LB 의 OUTPUT 이 사용될지 말지 결정되어 버려질 뿐이다.


7. 
이 문제는 어떤 Instruction 을 실행하는 과정을 담은 대서사시다.
- 32개의 32-bit word 길이의 Register 상태는 주어져 있다.
- Data Memory 는 싹다 0 으로 초기화 되어 있는 상태이다.

7.1
- Sign Ext. 는 하위 16비트만 취해서 연장시킨다. 그 결과를 묻는 것.
- Junp's SLL 란 표현은, imm 명령에서 사용하는 SLL 유닛이 아닌, 상단의 SLL 유닛을 사용한다는 표현이다.
ㄴ> 그리하여, 상단의 SLL 은 Tartget 26 비트를 28비트 데이터로 단순히 확장한다.

7.2
- ALU Control 이라는 유닛에는 총 2가지 Input 이 들어간다. 
- 명령어의 하위 6비트가 들어간다.
- 그리고 ALUop 가 들어가는데, 이것은 OPCODE 부분을 Control FSM 에서 조건문으로 분기시키기 때문에 표를 참고하지 않으면 알 길이 없다.


7.3 
- 알고보니 OP 코드는 SW 의 OP 코드였다. PC = PC + 4


7.4
-...

8. 

- 5개의 Pipeline Stage 들의 Latency 가 주어져 있다.
- 명령어들의 개수의 비율이 주어져 있다.


CYCLE TIME 에 대하여: CYCLE TIME 은 명령어를 실행하는 시간 계산의 한 최소 단위이다.

- Single Cycle 의 경우 명령어 한개 당 1 사이클을 취하므로 사이클 타임이 길다.
- 파이프라인 방식의 경우 Stage 5개 중 하나 를 수행하는데 필요한 시간을 사이클 타임으로 계산한다. 


8.1 : 파이프라인 방식, 그리고 Non-파이프라인 방식을 사용하였을 떄의 수행시간 차이

- 싱글 사이클은 앞서 말한대로 사아클 타임의 단위가 명령어 1개이다 -> 가장 긴 명령어인 LW 의 경우 5가지 Stage 를 모두 수행하여야 한다 - Linear 하게 더하기
- 멀티사이클의 경우 사이클 타임이 Stage 단위이다 -> 가장 긴 Stage 인 ID 의 수헹시간만 취하면 된다. 


8.2 : LW 명령어 하나를 수행한다. 각각의 레이턴시를 구하여라

- Non-Pipeline 의 경우 똑같이 Linear 하게 더하기.
- Pipeline 의 경우 앞서 설정한 350ps 라는 사이클 시간을 5회 돌리면 총 5개 스테이지가 전부 수행될 것이다.


8.3 : 파이프라인 방식에서, 사이클 타임을 줄일 방법을 강구하고 있다. 다섯 스테이지 중 하나만 쪼갤 수 있다고 하자.

- 가장 긴 Stage 하나를 쪼개면 파이프라인의 경우 좀더 사이클 타임을 작게 잡아줄 수 가 있음.


8.4 : 대충 데이터 메모리가 사용되는 lw 와 sw 메모리의 합을 물어보는 문제. 


8.5 : Write-Reg 가 사용되는 명령어의 비율을 물어보는 문제 : ALU와 lw 는 당연히 사용할 것이
- sw 는 메모리에 쓰지 Reg 에 쓰지 않는다.



9.

연관관계 모두 나열해
WAW : Write After Write
RAW : Read After Write
WAR : Write After Read

(1)
r1 : RAW, WAR,   + WAW (1 -> 3)
r2 : WAR, RAW

(2)
R 타이프이다. 2단계에서 읽고, 5단계 앞부분에서 Read
ㄴ> 딱 2번 기다리면, 3사이클 차이가 나면서 겹친다.
ㄴ> 그리고 5단계 앞부분에서 Write 하기 때문에 겹친 2단계의 Read 에 지장이 없다.

(3) 포워딩 했으면 해저드 없다.

(4) 총 3개의 instruction 이 겹쳐있다. Pipeline 을 하였을 때 총 5+2 사이클 필요하다.
ㄴ> 위에서 구한 대로 NOP 를 사용한 Stall 이 각각 2번씩 있다. (1->2, 2->3)
ㄴ> 따라서 포워딩을 하지 않는 경우 총 4사이클이 낭비된다. 
ㄴ> 7 사이클 vs 11 사이클 이 정답이다.

(5) 
- L1 에서 L2 로 R1 의 값을 넘겨주는 프로세스는 문제가 없다.
- 그리고 L2 에서 L3 로 ALU-ALU 포워딩을 하는 과정 역시 문제가 없다.
- 다만 문제는 L1 에서 L3 로의 포워딩에서 발생한다.
- L3 역시 L1 이 채 마무리되기 전에 시작된다.
- 따라서 포워딩이 필요한데, L3 의 3단계가 시작되기 반사이클 전 L1 은 4단계에 있다.
- 따라서 MEM to EX 포워딩이 필요해 지는 것이다 
- 그리고 이것은 문제에서 Prohibited 되어 있다. 따라서 1단계는 기다려야 한다.
- 이제 우리는 포워딩을 할 수 없다. 영락없이 L1 에서 R1 레지스터를 쓰기까지 온전히 기다려야 하는 것이다.
- 온전한 데이터가 필요한 순간은 L3 의 2단계이다. 그리고 NOP 1개만큼만 기다리면 둘이 겹쳐 버린다.
- 따라서 한사이클 더 기다려야 한다. 따라서 우리는 2개의 NOP 를 필요로 한다.

(6)
- 위에서 2사이클 넣었으니까 (7+2) * 290 이다.

10.

(1)
- 메모리 공간이 하나 뿐이라, Instruction 과 Data 두 메모리가 혼용된다.
- 따라서 1단계와 4단계가 파이프라인 상에서 겹치면 안된다.
- NOP 를 적절한 위치에 적절한 양 만큼 끼워넣으면 위의 Hazard 가 발생하지 않는다.
- 우선 정답은 세번째 명령어 다음 이다.

(2)
- Branch 로 인한 오류는 발생하지 아니한다고 전제하고 있다 
- 두가지 Case 를 비교 하여야 한다. 

- 첫번째 : lw 와 sw 의 메모리 해저드 문제를 해결하였다.
- 두번째 : 해결한 것에 더불어 3단계와 4단계를 오버래핑까지 했다.
ㄴ> 두 경우의 시행속도를 서로 비교하는 문제다.

(3)
Stall on branch : Branch 끝날때까지 기다리기

- Branch 명령어가 끝날때까지 명령어 실행을 기다리는 방법을 사용하기로 한다.
- 기초적인 상태는 위의 9 사이클 걸리는 상태에서 시작한다.
- Stall on Branch 로 인해서 총 2단계 늘어난다(Branch 의 3단계까지 기다리니까)
- 그런데 이  Branch 가 끝날때까지 걸리는 단계가 1단계 줄어들면 그만큼 총 시간도 1사이클 줄어든다
- 그래서 정답은 11 vs 10 사이클

(4) MEM 의 실행 시간이 20피코초 늘어난 것 외에는 2 와 동일한 상황이다.
따라서 사이클 횟수는 동일하되 사이클 타임만 20초 늘어난 상황이다.

(5) ID : 180, EX : 140 으로 조정되었다. 나머지 상황은 Branch 와 동일.

(6) 10.3 의 stall on Branch 상황. 

그런데 Branch 의 마무리 단계가 이제 4단계로 옮겨졌다.
ㄴ> 그냥 단순히 1사이클 지났다.

12.

(1)
- 레지스터에 Write 하는 과정은 5단계의 전반부에서 일어난다.
- 그리고, 이 데이터가 포워딩 없이 사용되려면 2단계와 5단계가 같은 사이클을 거치고 있어야만 한다.
- 그 조건을 1st (바로 뒤에 따라오는) Inst. 와 맞춰주기 위한 Stall 사이클이 2사이클 이다.
- 2nd only 의 경우 앞의 1st 가 사실상 stall 1사이클 만큼을 도맡고 있다고 할 수 있다.

비율에 맞게 Stall 을 계산하여 기본 CPI 에 더해주면 끝.

(2)
- Mem 에서 뒤따라오는 ALU 의 초입에 데이터가 Fowarding 되려면, 중간에 1stall 이 있어야 아다리가 맞는다


(3)
- EX/MEM 레지스터로부터 포워딩 하는 경우는, 오직 EX to 1st 에서의 Stall 만 방지해 준다.
- 그말인 즉슨 MEM to 1st 의 2stall, 그리고 나머지의 1 stall 전부 적용이다.
- Ex to 1st and Mem to 2nd 에 딸려있는 Ex to 1st 의 1 stall 도 면제된다.

- MEM/WB 레지스터로부터 포워딩 하는 경우를 보자. 
- Ex to 2ng

ㅋㅋㅆㅃ


13. 

(1)

- RAW 가 어느 지점에서 발생하는가를 알아 내야 한다.
- 그 다음 5단계 - 2단계 가 sync 되도록 적절히 Stall 을 섞어주면 된다

(2)

- 



==============================================================
CHPT 5 - Cache

Direct Mapped Cache
- 데이터가 Linear 하게 들어온다. (주소와 함께)
- 그리고 이것이 Cache 에 순서대로 누적된다. 단위는 Block.
- integer 데이터가 8자리수 이진수로 해석이 된다.

- 우선 오른쪽 4비트 - Index 를 식별한다.
- Block 의 개수에 따라서 Index 4비트 어떻게 읽어야 할지 구분
- index 읽었으면 왼쪽 4비트로 이동

- 문제에 따라 좌측의 4비트를 Tag 로 읽기도 하고
- 어떤 문제는 우측의 1비트까지 총 5비트를 Tag 를 읽는 데 사용하기도 한다.

ㄴ> 이말은 즉, Tag 를 식별하기 위해 사용된 비트가 Index 를 식별하기 위해 중복으로 사용되기도 한다는 것이다.


- 5장 초반부의 포인트는, 위 방법을 잘 숙지하여 우선 Index 와 Tag 를 읽는 것이다


2.

(1)

- 우선 32bit 주소들을 Binary No. 로 나타낸다. 
- 총 8 비트만 일단 나타냈다. 이들 중 앞의 4자리는 Tag 라 하고, 뒤의 4 자리는 Index 라고 한다.

(3)

- 1 Word Blocks 의 경우 : index 쪽에서 0비트가 Offset 으로 사용된다.

- 2 Word Blocks 의 경우 : index 쪽에서 1비트가 Offset 으로 사용된다.

- 4 Word Blocks 의 경우 : index 쪽에서 2비트가 Offset 으로 사용된다.

Cycle 계산하기

- Processing Time : 모든 데이터에 대하여 곱셈해서 더해줘야 한다
- Miss Stall Time : Miss 가 발생하여 메모리에서 데이터를 직접 가져와야 하는 경우 소요되는 시간이다.







