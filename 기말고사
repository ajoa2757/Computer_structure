# Computer_structure
2021 1학기 컴퓨터구조론 내용정리

CHPT 4

=======================
4A - Single Cycle

Control 유닛의 변수들

Reg Dst : 0 일 경우, imm 을 사용하는 명령어이고, 1 일 경우 R 을 사용하는 명령어이다.
ㄴ> 연산의 데스티네이션을 어디로 보낼 지 결정하는 변수라고 하겠다.

Reg Write : Write data 란의 항목이, Write Register 레지스터에 입력된다.
ㄴ> R 타이프일때 1 이 된다고 할 수 있는 것일까?

ALU Src : 1 일 경우, ALU 의 두번째 란에 들어갈 값을 imm 영역에서 가져온다. 즉 I 계통 명령어라는 뜻.
ㄴ> 반대로, 0 일 경우 ALU 의 두번째 란에 들어갈 값을 정상적으로 rt 란에서 가져온다고 하겠다.

PC Src : 1 일 경우, branch 명령어를 수행하겠다는 것으로 간주한다.
ㄴ> 0 일 경우, 일반적인 방법으로 PC = PC + 4 한다.

MemRead : load 명령어.
MemWrite : save 명령어. 

MemtoReg : 0 일 때 Save, 1 일때 Load 계통이다.

======================
4B - MultiCycle

새로운 Control 변수들

ALUSrc A : 0 일 경우 PC 를 Input 으로 받는다.
ALUSrc B : 총 4가지 Case 가 있다.

- 일반적인 I 타이프 명령어
- 일반적인 R 타이프 명렁어
- sll 을 위해 4를 받는 Case
- Branch 를 위해 Shift 2 된 imm 을 받는 Case

PCSrc : 총 3가지 Case 가 있다.
- PC +4 (일반적 케이스)
- ALU Out 의 결과물로 점프하는 Case
- Jump 의 Target Address 로 점프하는 Case

ALUOP : 3가지 케이스가 있다.

- Funct 의 코드를 따르는 일반적 경우
- Add 와 Sub 두가지 Case


lorD : 0 이면 PC 가 매모리 유닛으로의 주소를 저장한다. 1이면 ALUOut 이 저장한다.

IRWrite : 1이면 IR 의 주소로 데이터가 Write 된다.



Multicycle - 메카니즘

싱글사이클 이상의 명령어 체계는 총 5가지로 명령어를 세분한다. 그리고 이 세분된 덩어리 하나당 1 사이클을 차지한다.

Instruction Fetch : 명령어 메모리 IM 으로부터 명령어를 가져온다.
Instruction Decode : 명령어가 디코드되어 Register File 영역으로 옮거진다. 
Execution : 받은 컨트롤 변수들에 의해 ALU 가 적절히 동작하여 값을 여기저기에 전달한다.
Memory Acess : 메모리 영역에 값을 읽거나 쓴다.
Memory read Completion : 레지스터 영역에 값을 읽거나 쓴다.


- 총 5가지 단계이다.
- R 타입은 총 4단계까지 진행하면 종료다.
- load 는 5단계, store 는 4단계까지 필요하다.
- Branch 의 경우 3단계에서 종료로 가장 짧다 (SLL 된 값이, ALU 의 동작 타이밍에 ADD 를 거치면서 PC 를 업데이트시킨다.)
- jump 의 경우도 마찬가지


이때, 멀티사이클의 1사이클 타임은 어떻게 결정되는가?
=> 5가지의 Instruction Block 들 중에서 레이턴시가 가장 큰, 즉 가장 느린 블록의 수행시간을 1사이클 타임으로 잡는다.

멀티사이클의 FSM

- 상술한 컨트롤 변수들은, State Machine 라는 것을 사용하여 기술된다.
- 각 State 들은 Instruction Block 들을 더욱 세분한 것이며, 각 스테이지마다 Control 변수들이 조정된다.
- 그리고 각 State 들은 알맞은 다음 Stage 로 이동한다. 스테이지 내부의 컨트롤 변수들은 이 흐름을 조정하는 역할을 하기도 한다.


- 더 쪼개짐으로 인해서, 가장 길게 걸리는 Instruction 을 기준으로 설정되었던 Cycle Time 으로 인한 Waste 를 없엘 수 있다.


========================
파이프라인 - 원리

- 앞서 멀티사이클에서, 명령어의 실행을 총 5가지 스테이지로 나눴다.
- 그리고 프로세서의 물리적인 구조 역시, 이 5가지의 스테이지를 공장 생산라인을 거치듯이 구성하였었다.

- 그렇다면, 이 5개의 생산 벨트를 동시에 돌릴 수는 없을까? 
- 그렇게 되면, 총 5개의 스테이지가 1사이클마다 전부 동작하니, 1사이클 당 1개의 명령어가 실행되는 효과를 볼 수 있다.
ㄴ> 한번에 5개 이상이 동작하면 어떤 스테이지는 한번에 두개의 명령어를 처리해야 되기 때문에 논리적으로 불가능하다.
ㄴ> 총 5개의 명령어만 한번에 동작 가능한 것은 이러한 이유에서이다.


Pipeline - Hazards

- 당연히 이러한 방식에는 문제가 생길 여지가 있다.

- 만약, 어떤 한 레지스터에 읽고 쓰는 명령어 두개가 연속으로 놓여 있다고 하자.
- 그렇다면, 레지스터에 새로운 값을 쓰기도 전에 그 다음 명령어가 읽어 버린다면 어떤 일이 발생할까?
- 당연히 개발자가 유도하지 않은 방향으로 프로그램이 동작하게 될 것이다. 이것을 해저드라고 하기로 했다.

- 발생 가능한 해저드의 상황은 어느정도 예상될 수 있다. 
- 해저드가 예상 되었다면, 단순히 쓰기 작업이 끝날 떄 까지 읽기 명렁어가 기다리게 할 수 있다. 


Hazard - 구조적 해저드

- 어떤 sw 명령으로 메모리에 값을 쓴다고 하자.
- store 과정이 완료되기 전에 load 명령어가 해당 메모리에서 값을 가져다 쓰려고 한다면 곤란한 상황이 발생할 것이다.
- 레지스터에도 마찬가지. 

- 이것은, 읽기를 쓰기보다 느리게 하는 것으로 어느정도 문제의 발생 확률을 낮출 수 있다.
- 쓰기는 갱신이다. 읽기는 가능한 늦게 읽을수록, 더 최신화된, 즉 더 알맞게 갱신된 값을 읽을수 있도록 한다. 당연한 이야기다.

Hazard - 의존성 해저드

최신화된 데이터는 항상 W 에서 발생한다. 

- RAW 상황 : Read After Write. R 이 맨 앞글자이지만 사실 R 이 뒤에 실행되는 것이 문제임을 지적하는 것이다.
ㄴ> 사실상 가장 의미있는 의존성 해저드이다.

- WAW 상황 : 앞선 Write 가 마쳐지기도 전에 그 다음의 Write 명령어가 실행되고 있는 상황이다.
- WAR 상황 : R 가 끝마쳐지기 전에 W 가 실행되는 상황.
ㄴ> 이 두가지 상황은 사실 해저드로 치지 않는다고 봐도 무방하다. 


의존성 해저드의 해결 - Stalling

- Stalling 은 기다린다는 뜻이다.
- 우리는 앞서, 읽기를 더 늦게, 쓰기를 더 빠르게 하도록 하였다.
- 따라서, 최신화를 하는 쓰기와 그것을 읽는 읽기가, 최소한 같은 싸이클에 동작해야 한다.
- RAW Hazard 는 그리하여 2사이클을 손해보게 만든다.

ex) Stalling 으로 인한 새로운 CPI 계산

- 만약 40퍼센트의 명령어가 Stalling 을 발생시킨다고 해 보자.
- 발생 시동 명령어의 CPI 를 생각해 보자. 

한참 제대로 작동중인 파이프라인은 원래 1 의 CPI 를 가지도록 되어 있다.
그런데 여기에, stalling 으로 인해서 2개의 사이클을 손해를 보고 말았다. 이것은 오롯이 시동 명령의 책임이다.

그렇다면 새로운 CPI 는, 기존에 내던 성적인 1 에다가 2 사이클을 추가로 더해야 한다는 말이다.
이러한 명령어가 총 40퍼센트나 된다.

=> 그렇다면, 총 CPI 는 1 + 0.4 *2 = 1.8 되시겠다.


의존성 해저드의 해결 - Forwarding

- ALU 에서 값이 최종적으로 산출되는 단계는 3단계의 말미이다.
- 레지스터에 Write 가 일어나는 단계는 5단계의 선미이다.

- ALU 에서 산출된 값을, 어디다 담아놨다가, Write 과정이 완료되기 전에 미리 쏴줄 수 없을까

- 레지스터를 사용하는 연산의 경우, 앞의 2 사이클 쉬어가는 것 막을 수 있다.

- lw 명령어의 경우, 레지스터가 갱신되는 타이밍이 빨라야 4단계의 말미이다. ( 쓰기는 읽기에 우선하므로 )
- 따라서, 해당 메모리의 값을 늦게 받아도 3단계의 ALU 에서 받아야 하는데, 여전히 1사이클은 쉬어줘야 한다. 


Control Hazard

- Branch 명령어가 있다고 하자. 4단계 전반에 가서야 PC 가 업데이트 된다고 한다. ( 3단계가 아닌가 싶지만 PC 에 값을 쓰는 거니까..4단계 전반)
- 그런데, 4단계가 실행되기 전에, 이미 1단계에서 업데이트된 PC +4 에 따라서 프로그램이 계속 실행되면?
- 심각한 문제다. 

Control Hazard 의 해결

- Stall : 4단계까지 기다려야 한다. 4사이클 손해
- Predict - Not taken : 그냥 명령문을 실행하되 그 결과를 리셋시켜버린다
- Predict - Taken : 명령문을 실행하고, 결과물을 올바른 위치로 다시 전달하기까지 한다. 
ㄴ> 많은 경우 Predict 방법이 쓰인다. 




파이프라인과 컨트롤 변수들

- 컨트롤 변수들이 1사이클마다 ID 단계에서 업데이트 된다면 혼란이 발생할 것이다.
- 별 문제 없다. 레지스터와 메모리에 사용될 데이터들과 함께 컨트롤 변수를 파이프라인을 따라 이동시키면 문제 없다.
- 각 컨트롤 Signal 들은 사용되는 단계가 제각각이다. ID 에서 생성된 뒤 마지막 Reg 단계에서 사용되는 경우도 있다.


==================CHPT 5====================



////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////여기부턴 문제풀이 영역에서 훔쳐본 것들///////////////////////////\
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
Logic Blocks : I-MEM, Add, Mux, ALU, Regs, D-Mem, Sign-Extend, Shift-Left-2

ㄴ>Cycle Time 을 위 Logic Block 들이 사용되는 Path 를 바탕으로 알아야 한다.

4.1
Instruction Fetch : PC = PC+4 , IR = Memory[PC} 2가지의 LB 가 필요하다.

ㄴ>이들은 I-MEM, Add 위 두개의 Logic Block 들을 필요로 한다.
ㄴ>특이사항으로, PC 메모리에서 Load 하고 +4 하여 Feedback 하는 과정은 동시에 일어난다.

ㄴ>따라서 이 둘 중 에서 더 오래 걸리는 I-MEM 의 레이턴시가 Cycle Time 이 된다.


4.2
Unconditional Branch 명령어 : MIPS 의 "b" 명령어. I-MEM, Sign-Ext, SLL, ADD, MUX 총 5가지의 LB 가 필요하다.

ㄴ> 이번엔 이들의 레이턴시를 선형적으로 모두 더한다.
ㄴ> 이 문제에 나온 경우는 특히 Unconditional 이다. bne 의 경우처럼 Regs, ALU 등을 사용할 이유가 없다.
ㄴ> 그래서 imm 영역의 데이터를 가공하는 Sign-Ext, SLL 등만 사용한다. 


4.3
Conditional Branch 명령어 : MIPS 의 "beq" 명령어. I-MEM, Reg(+Sign Ext.), Mux(+SLL), ALU(+Add), Mux 총 5가지의 LB 가 필요하다.

ㄴ> 괄호 안의 동작들은 동시에 동작하는 LB 들이다. 다만 이들은 괄호 밖의 더 빠른 동작들에 잡아먹혀(마치 4.1 의 Add LB 처럼) 드러나지 않는 것이다.
ㄴ> Conditional Path 이기 때문에, Reg, Mux, ALU 로 통하는 조건식 비교연산이 수행되어야 하기 때문에, Cycle Time 이 더 길다.



4.4, 4.5 & 4.6

4.4 : 위 LB 들의 정보들은 어떤 종류의 Instruction 들이 필요로 할까 : 정답은 PC-Relative Branches
4.5 : 어떤 Instruction 들이 위의 LB 들을 Critical Path 로 사용하는가? : PC-Relative, Unconditional Branches
ㄴ> MIPS 의 오리지널 명령으들의 경우 
4.6 : Conditional 과 Unconditional 의 비교이다. "b" 와 다르게 "beq" 만 사용하는 경우 105 가 더 길어지는 상황을 이야기하고 있다.


5.

5.1 : Data Memory 를 사용하는 명령어의 비율만 뽑아보라는 문제. Lw 와 Sw 의 비율을 더하면 된다.
5.2 : Sign-Extend LB 에 대한 이야기
ㄴ> I-Type 의 제시된 명령어들 - addi, LW, SW, BEQ 이들은 모두 I-Type 이기 때문에 Sign-Ext. 사용한다.
ㄴ> 다만, 해당 LB 가 필요하지 않더라도, 계산은 항상 이루어지고 있다. 다만 MUX 를 통해 이 LB 의 OUTPUT 이 사용될지 말지 결정되어 버려질 뿐이다.


7. 
이 문제는 어떤 Instruction 을 실행하는 과정을 담은 대서사시다.
- 32개의 32-bit word 길이의 Register 상태는 주어져 있다.
- Data Memory 는 싹다 0 으로 초기화 되어 있는 상태이다.

7.1
- Sign Ext. 는 하위 16비트만 취해서 연장시킨다. 그 결과를 묻는 것.
- Junp's SLL 란 표현은, imm 명령에서 사용하는 SLL 유닛이 아닌, 상단의 SLL 유닛을 사용한다는 표현이다.
ㄴ> 그리하여, 상단의 SLL 은 Tartget 26 비트를 28비트 데이터로 단순히 확장한다.

7.2
- ALU Control 이라는 유닛에는 총 2가지 Input 이 들어간다. 
- 명령어의 하위 6비트가 들어간다.
- 그리고 ALUop 가 들어가는데, 이것은 OPCODE 부분을 Control FSM 에서 조건문으로 분기시키기 때문에 표를 참고하지 않으면 알 길이 없다.


7.3 
- 알고보니 OP 코드는 SW 의 OP 코드였다. PC = PC + 4


7.4
-...

8. 

- 5개의 Pipeline Stage 들의 Latency 가 주어져 있다.
- 명령어들의 개수의 비율이 주어져 있다.


CYCLE TIME 에 대하여: CYCLE TIME 은 명령어를 실행하는 시간 계산의 한 최소 단위이다.

- Single Cycle 의 경우 명령어 한개 당 1 사이클을 취하므로 사이클 타임이 길다.
- 파이프라인 방식의 경우 Stage 5개 중 하나 를 수행하는데 필요한 시간을 사이클 타임으로 계산한다. 


8.1 : 파이프라인 방식, 그리고 Non-파이프라인 방식을 사용하였을 떄의 수행시간 차이

- 싱글 사이클은 앞서 말한대로 사아클 타임의 단위가 명령어 1개이다 -> 가장 긴 명령어인 LW 의 경우 5가지 Stage 를 모두 수행하여야 한다 - Linear 하게 더하기
- 멀티사이클의 경우 사이클 타임이 Stage 단위이다 -> 가장 긴 Stage 인 ID 의 수헹시간만 취하면 된다. 


8.2 : LW 명령어 하나를 수행한다. 각각의 레이턴시를 구하여라

- Non-Pipeline 의 경우 똑같이 Linear 하게 더하기.
- Pipeline 의 경우 앞서 설정한 350ps 라는 사이클 시간을 5회 돌리면 총 5개 스테이지가 전부 수행될 것이다.


8.3 : 파이프라인 방식에서, 사이클 타임을 줄일 방법을 강구하고 있다. 다섯 스테이지 중 하나만 쪼갤 수 있다고 하자.

- 가장 긴 Stage 하나를 쪼개면 파이프라인의 경우 좀더 사이클 타임을 작게 잡아줄 수 가 있음.


8.4 : 대충 데이터 메모리가 사용되는 lw 와 sw 메모리의 합을 물어보는 문제. 


8.5 : Write-Reg 가 사용되는 명령어의 비율을 물어보는 문제 : ALU와 lw 는 당연히 사용할 것이
- sw 는 메모리에 쓰지 Reg 에 쓰지 않는다.



9.

연관관계의 
WAW : Write After Write
RAW : Read After Write
WAR : Write After Read





