# Computer_structure
2021 1학기 컴퓨터구조론 내용정리

학습목표 : 레지스터 사용법을 숙지한다.

1. C언어 코드
2. 컴파일러를 통한 어셈블리 코드
3. 어셈블러를 통한 머신코드
4. 머신코드를 통한 신호처리

기존의 Memory-memory ISA : 메인메모리에 직접 엑세스할 수 있다.

MIPS : 메인메모리에 억세스하려면 Resister 를 통해야 한다. Load store ISA 라고 한다.

-메인메모리는 크기가 크기 때문에 명령어 하나를 읽기에 시간이 많이 든다.
-메인으로부터 32비트 레지스터로 데이터가 로드되고, 다시 메인 메모리로 스토어된다.


-총 32비트 레지스터의 주소별 사용처

$zero : 0이 저장되어 있다. 고정되어 있다.
$v0, v1 : 값을 반환할 때 사용한다.
argument $a0~a3 : 함수로 매개변수를 전달할 때 사용된다.
temporary $t0 ~ t9 : 피호출함수가 자유롭게 사용할 수 있는 영역
store $s0 ~ s7 : 호출함수가 자유롭게 사용할 수 있는 영역

$at : 어셈블러용
$k0, k1 : os 커널용

==================
-caller & callee
ㄴ>callee 는 호출되는 함수.
ㄴ>caller 역시, 필요에 따라 t 계통 영역을 사용할 수 있다.
ㄴ>이때 t 레지스터의 데이터를 스택에 푸쉬하여 저장하고 pop 하여 사용 한다.
ㄴ>caller 가 사용하였던 것을 callee 가 사용할 때 혼용이 없도록 해야 하기 때문
ㄴ>그래서 t 를 caller saved 영역이라고 하기도 한다.

ㄴ>s 레지스터 역시 callee 에 의하여 사용될 수 있다.
ㄴ>callee 가 $s 의 값을 사용하고 스택에 푸쉬한 뒤에,
ㄴ>caller 가 해당 레지스터를 사용하고
ㄴ>callee 는 스택에 푸쉬된 값을 다시 pop 하여 $s 를 다시 사용하는 식이다.

=====================
레지스터 파일

두개의 읽기포트와 한개의 쓰기포트로 이루어져 있다.

write 는 5비트 주소와 32비트 데이터인풋이 주어진다.

read 는 주소 5비트 32비트크기 읽기포트 '두 쌍'으로 이루어져 있다. 

-레지스터가 크기가 커지면 더 느려질 것이다. 명령어 길이기 너무 길어지기 때문


=====================
명령어 컴포넌트

1. 계산이름
2. 목표지점
3. 원본지점 1,2

-> add dst, src1, src2
ㄴ>이것은, dst(destination) 으로 src1, src2(sourcse 1,2) 의 값들을 더한 것을
제출하는 명령이 되겠다.

ㄴ>add $1, $1, $1 : $1 에 2가 들어있다고 하자. 2+2 가 전달되어 $1 은 4가 된다.

=====================
산술명령어

각 명령어는 32비트로 구성되어 있다.

순서는 무조건 계산이름-목표지점-원본지점1-원본지점2 이다.

a = b+c
= add $1, $2, $3

a = b+c+d-e
= add $t0, $s1, $s2   #b+c 가 t0 에 임시저장된다
=> add $t1, $t0, $s3  #t0 + d 가 t1 에 임시저장된다
=> sub $s0, $t1, $s4  #t1 - e 가 a 에 저장된다


*메모는#으로 한다
*연산자 하나당 명령어 하나가 필요하다.

====================
명령어의 레지스터상 배치

1. 계산이름은 op 와 funct 영역에 배치된다
2. 목표레지스터의 정보는 rd 에
3. 소스1 레지스터의 정보는 rs에
4. 소스2 레지스터의 정보는 rt에 저장된다

=====================
상수

상수를 명령어에 직접 담아야 하는 경우도 생긴다. 이것을 immediate 필드라 한다

imm은 16비트 signed value 를 가질 수 있다. 그래서 imm 을 사용하는 I 형 명령은, 총 32비트 중 16비트를 Immediate 를 위해 사용한다

imm 필드를 사용하는 연산은 계산이름에 i가 붙는다
*가령, add 는 addi
====================
상수사용의 방법

MIPS 는 레지스터 0 를 고정적으로 저장하고 있다.

slti 명령어 : set less then imm, 'slti $t0, $s2, 15' 이라고 하자.
ㄴ> s2에 저장된 값이 imm 필드의 값인 15보다 작다면, t0 가 1이 된다.

====================
Sign extension

unsigned 32비트는 0~2^32-1 까지표현가능

2의보수 음수
1. 맨앞 1비트가 부호비트로 사용된다.
2. 음수는, '절댓값의 이진수 표현' ->  비트반전 -> + 1 로 표현된다.


signed & unsigned 수들의 연산에 대한 명령어들이 각각 존재한다.
ㄴ>명령어 뒤에 unsigned 만 u가 붙는다.
ㄴ>가령, addiu 는 unsigned imm 을 사용하는 덧셈이 되시겠다.

-unsigned 는 주로 주소를 표현할 때 사용된다. 그래서, 오버플로우를 경계하지 않는다.
-signed 계통 명령어들은 sign extention 을 사용하여 오버플로우에 대처한다.

-addiu 와 같은 명령을 할 때 주의해야 한다. imm이 주로 2의 보수로 표현되기 때문에, 
이런 경우는 sign extention 을 해 줘야 한다. 
===================
데이터 전송명령

MIPS 에서는 load 와 store 를 사용한다.
ㄴ>load 는 메인으로부터 가져올때
ㄴ>store 는 메인으로 write 할때


읽고 쓰는 단위는 32비트 word, 16비트 half-word, 8비트 byte 가 있다.

ㄴ>부동소수점 표현을 사용한 명령어군은 따로 존재한다.
ㄴ>메모리의 주소를 생성하는 방법은 dispacement addressing mode 뿐이다.

lw : load word, 32비트를 읽어온다. 
ㄴ> lw $t0, 4($s3) 는 s3는 base address, 4는 offset 이라 한다.
ㄴ> 목표지점은 t0. t0 = 's3안에 담긴 주소값 +4 ...의 주소에 위치한 값' 이 되겠다.


sw : store word, 32비트를 메인 메모리에 쓴다.
ㄴ> sw $t0, 8($s3) : source 는 t0 이다. destination 주소는 (s3에 담긴 주소값 + offset) 이다.
ㄴ> offset 은 16비트 2의 보수이므로 2^15-1 ~ -2^15 가 offset 의 범위이다.

*offset 이라는 이름의 imm 을 사용하므로 이러한 명령어들은 I format 을 사용한다. 

load word 의 예시

a= b+ *c 를 보자. 우리는 c로부터 값을 읽어와야 한다.
1. lw $t0 0(s2) : s2(=c) 안에는 주소가 담겨 있다. offset 0로 read되고, t0에 단느다
2. add $s0, $s1, $t0 : 불러온 값을 s0(=a) 에 저장한다.

*a = b+c 를 보자. 우리는 a가 가리키는 주소에 값을 전달해야 한다.
1. add $t0, $s1, $s2 : b+c 가 t0에 전달된다
2. sw $t0, 0($s0) : t0 가 s0에 offset 0 로 write 된다.


ㄴ>말하자면, int 가 아니라 int* 를 쓰고자 할때 사용하는 연산.
ㄴ>연산자 문법을 잘 숙지하도록 하자.

====================
array

배열의 이름은 포인터이다.

배열의 n번째 원소의 주소는, 
ㄴ> base address + n * 배열원소의 크기 이다.
ㄴ> 가령, 20번지에 저장된 int 배열 pow 의 5번째 원소는..
ㄴ> 20 + 5 * 4 = 40 이 되겠다. 
=====================
shift 명령어

int pow2[a] 가 있다.

a 를 사용하여 해당 주소의 위치를 나타내려면, a에 4를 곱한 것을 사용해야 한다.

sll = $t0, $s0, 2 ( shift left logical)
ㄴ> a는 $s0, pow 의 base 는 $s3 이라 하자.
ㄴ> $s0 값을 2 만큼 왼쪽으로 shift 하여 t0에 저장한다.
ㄴ> 곱 4 한것과 다른바가 없겠다.
ㄴ> 게다가 더 빠르다

ㄴ>add $t1, $t0, $s3
ㄴ>base 주소인 s3과, index address 인 t0를 더해 pow[a] 의 주소를 얻는다. 이것이 t1에 저장된다.
ㄴ>lw $v0, 0($t1) : pow[a] 의 주소 t1 에서 읽어다가 v0에 저장한다
=====================
*store floating point 뭔지 모르겠는데 61페이지에서 지울 것!

-Shift operation 
ㄴ>logical shift 는 항상 빈 자리에 0이 채워진다.
ㄴ>Arithmetic Shift right(shift) 의 경우, 옮겨지는 원소의 (0 or 1) 이 카피된다
ㄴ>어떻게 옮기느냐에 따라 빈자리에 채워지는 값 달라지는데 이거 파악할 것

-Conditional & unconditional branch 명령 다른 것 숙지할 것

-메인 메모리. 사이즈는 4바이트(모든 명령어가 4바이트로 처리)
ㄴ>명령어들의 주소 allignment 는 4의 배수로 시작.
ㄴ>명령어는 그래서 16비트짜리 offset 을 사용한다
ㄴ>그래서 레지스터 끝에 00 이 들어간다.
ㄴ> 4바이트 단위로 사용하기 위함...


====================
Alignment restrictions

메모리의 주소는 4의 배수라고 위에서 이야기 하였다.

이것을 반영하여, CPU가 메모리에, 데이터를 4바이트 단위로 기록하면, 그것을
Alignment Resriction 이라고 부른다. 
ㄴ>가령, word 는 4에서 7번지에 기록될 수 있다.
ㄴ>허나, 5~8번지에는 저장될 수 없다.

따라서, Word 는 4의 배수 번지에, half word 는 2의 배수 번지에. 그런 식이다
ㄴ>n 바이트의 변수는 n 배수의 주소에만 배치된다.

====================
Big & Middle 엔디안 방법

메모리 1004 번지부터 1007 번지에 워드 데이터를 하나 저장하려고 한다.

우리는 word를 4~7까지 순방향으로 입력할 것인지 아니면 역방향으로 입력할 것인지 결정할 수 있다.
ㄴ>순방향 입력을 Big endian, 역방향 입력을 little endian 이라고 부른다.
ㄴ>MIPS 는 두 방법의 해석을 모두 사용할 수 있다.

======================
바이트 이동 연산자

lb $t0, 1($s3)
ㄴ>load bite from memory, ($s3 는 주소 데이터를 가지고 있고, t0 는 진짜 데이터를 저장하는 공간이다.)
ㄴ>메모리의 s3 + offset 번지의 1바이트(=8비트) 를 읽어 트랜지스터 t0 의 LSB 에 load 한다

ㄴ>목적지 레지스터(32비트) 의 나머지 자리 3바이트는 그럼 어떻게 처리되는가?
ㄴ>sign, 즉 자료의 맨 앞 자리에 위치하는 부호 정보가 그대로 복사된다
ㄴ>unsigned 데이터의 경우 무조건 0으로 된다.

sb $t0, 6($s3)
ㄴ>store bite to memory
ㄴ>t0 의 LSB에 존재하는 데이터를 s3 + offset 번지에 store 한다.

두 명령은 모두 I format 을 사용한다. 

lb는 sign extension 을 실시한다. 
ㄴ>이것이 무슨 말이냐, LSB(least significant byte) 에 데이터가


======================
half word 이동 연산자.

위와 동일한 양식이지만 다만 lb 가 아니라 lh(half-word) 이다.
ㄴ>sign extention 으로 남은 공간을 처리하는 방식도 똑같다

===================
논리연산자

and, or, nor 연산자가 op 부분에 제공되면 정상적으로 작동한다.
ㄴ>다만, imm을 사용하는 경우 andi, ori 와 같은 형태가 된다.

===================
32비트 데이터 사용?

MIPS 명령어는 한 행이 32비트로 이루어진다. 이중 16비트가 imm 으로 사용된다.

이때, 상수를 32비트 상수를 사용하고 싶은 상황이라면 어떻게 할까 ?

lui $t0, (16bit data) : 32비트짜리 명령어 $t0 의 공간에, imm 16bit data 가 기록된다. 
ㄴ>ori $t0, t0, (16bit data : 이 두 명령어를 사용하면, 두 16비트 데이터가 $t0 에서 32비트 데이터로 합쳐지게 된다.

=================
비교연산자 bne, beq

bne $s1, $s2, Lbl : s0와 s1 이 같지 아니하면, Lbl 로 goto 하는 명령문이다.
ㄴ> 앞에 beq 로 하면 s0 와 s1 이 같은 상황의 논리연산이 이루어진다.

비교연산자를 통해 goto 하였다고 하자.

일반적으로 PC(프로그램 카운터) 는 한 명령을 할때마다 PC+4 되어 다음 명령어를 진행하게 된다.

이때 제어문을 통한 조작은 16비트 offset 을 사용하여 PC 를 조작한다. 따라서 16비트 signed int 의 범위만큼만 PC 가 조정될 수 있다. 

=================
if, then, else 

간단한 if/else 조건문을 어셈블리어로 만들어 보도록 하자.

bne $s0, $s1 Lb1
add $s2, $s0, $s1
j Exit
Lb1:sub $s2, $s0, $s1
Exit : 

ㄴ> 1. bne 문에서 s0 과 s1 레지스터의 내용이 비교된다.
ㄴ> 2. 만약 같다면, 점프가 일어나지 않는다 => 즉, add문이 실행된다. 그리고 Exit 으로 점프 한다.
ㄴ> 3. 만약 아니라면, Lb1으로 향해서 sub 문이 실행된다. 그리고 Exit 에서 만난다.


조건문엔 다양한 것이 있다. 

stl : set on less than

slt $t0, $s0, $s1
ㄴ> 만약 s0 가 s1 보다 작으면, t0 는 1로 세팅 될 것이다.
ㄴ>t0 는 '$s0 가 s1 보다 작은가?' 의 true/false 를 담고 있다.

bne $t0, $zero, Less
ㄴ>t0 가 false 가 아니라면(=t0가 true라면, = s0가 s1보다 작다면), Less 로 간다. 
ㄴ>그게 아니라면 점프하지 않는다. 

ㄴ>slt 문은 R포멧을 사용한다.


==================
Q. 모든 연산자들의 명령문 op 영역에 할당되는 넘버를 인지하고 있어야 하는가


-MIPS 비교구문
ㄴ>가령, 특정 범위를 설정한 if 문을 생각하자.
ㄴ>'sltiu' : set less then imm under


명령어를 워드 

