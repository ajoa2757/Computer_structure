# Computer_structure
2021 1학기 컴퓨터구조론 내용정리

학습목표 : 레지스터 사용법을 숙지한다.

1. C언어 코드
2. 컴파일러를 통한 어셈블리 코드
3. 어셈블러를 통한 머신코드
4. 머신코드를 통한 신호처리

기존의 Memory-memory ISA : 메인메모리에 직접 엑세스할 수 있다.

MIPS : Resister 를 통한다. Load store ISA 라고 한다.

-메인메모리는 크기가 크기 때문에 명령어 하나를 읽기에 시간이 많이 든다.
-산술연산 명령어는 레지스터로 이루어진다.
-메인으로부터 32비트 레지스터로 데이터가 로드되고, 다시 메인 메모리로 스토어된다.


-총 32비트 레지스터의 주소별 사용처

$zero : 0이 저장되어 있다. 고정되어 있다.
$v0, v1 : 값을 반환할 때 사용한다.
argument $a0~a3 : 함수로 매개변수를 전달할 때 사용된다.
temporary $t0 ~ t9 : 피호출함수가 자유롭게 사용할 수 있는 영역
store $s0 ~ s7 : 호출함수가 자유롭게 사용할 수 있는 영역

$at : 어셈블러용
$k0, k1 : os 커널용

==================
-caller & callee
ㄴ>callee 는 호출되는 함수.
ㄴ>caller 역시, 필요에 따라 t 계통 영역을 사용할 수 있다.
ㄴ>이때 t 레지스터의 데이터를 스택에 푸쉬하여 저장하고 pop 하여 사용 한다.
ㄴ>caller 가 사용하였던 것을 callee 가 사용할 때 혼용이 없도록 해야 하기 때문
ㄴ>그래서 t 를 caller saved 영역이라고 하기도 한다.

ㄴ>s 레지스터 역시 callee 에 의하여 사용될 수 있다.
ㄴ>callee 가 $s 의 값을 사용하고 스택에 푸쉬한 뒤에,
ㄴ>caller 가 해당 레지스터를 사용하고
ㄴ>callee 는 스택에 푸쉬된 값을 다시 pop 하여 $s 를 다시 사용하는 식이다.

=====================
레지스터 파일

두개의 읽기포트와 한개의 쓰기포트로 이루어져 있다.

write 는 5비트 주소와 32비트 데이터인풋이 주어진다.

read 는 주소 5비트 32비트크기 읽기포트 '두 쌍'으로 이루어져 있다. 

-레지스터가 크기가 커지면 더 느려질 것이다. 명령어 길이기 너무 길어지기 때문


=====================
명령어 컴포넌트

1. 계산이름
2. 목표지점
3. 원본지점 1,2

-> add dst, src1, src2
ㄴ>이것은, dst(destination) 으로 src1, src2(sourcse 1,2) 의 값들을 더한 것을
제출하는 명령이 되겠다.

ㄴ>add $1, $1, $1 : $1 에 2가 들어있다고 하자. 2+2 가 전달되어 $1 은 4가 된다.

=====================
산술명령어

각 명령어는 32비트로 구성되어 있다.

순서는 무조건 계산이름-목표지점-원본지점1-원본지점2 이다.

a = b+c
= add $1, $2, $3

a = b+c+d-e
= add $t0, $s1, $s2   #b+c 가 t0 에 임시저장된다
=> add $t1, $t0, $s3  #t0 + d 가 t1 에 임시저장된다
=> sub $s0, $t1, $s4  #t1 - e 가 a 에 저장된다


*메모는#으로 한다
*연산자 하나당 명령어 하나가 필요하다.

====================
명령어의 레지스터상 배치

1. 계산이름은 op 와 funct 영역에 배치된다
2. 목표지점은 rd 에
3. 소스1 은 rs에
4. 소스2 는 rt에 저장된다

=====================
상수

상수를 명령어에 직접 담아야 하는 경우도 생긴다. 이것을 immediate 필드라 한다

imm은 16비트 signed value 를 가질 수 있다.

imm 필드를 사용하는 연산은 계산이름에 i가 붙는다
*가령, add 는 addi
====================
상수사용의 방법

MIPS 는 레지스터 0 를 고정적으로 저장하고 있는 경우가 있다.
ㄴ>imm 을 사용할 땐 i 포멧을 사용한다.
ㄴ>i포멧의 명령어에서는 ,16비트 크기의 값이 imm 형식으로 사용될 수 있다.

slti 명령어 : set less then imm, 'slti $t0, $s2, 15' 이라고 하자.
ㄴ> s2에 저장된 값이 imm 필드의 값인 15보다 작다면, t0 가 1이 된다.

====================
Sign extension

unsigned 32비트는 0~2^32-1 까지표현가능

2의보수 음수
1. 맨앞 1비트가 부호비트로 사용된다.
2. 음수는, '비트반전(양수) + 1' 로 표현된다.


signed & unsigned 수들의 연산에 대한 명령어들이 각각 존재한다.
ㄴ>명령어 뒤에 unsigned 만 u가 붙는다.
ㄴ>가령, addiu 는 unsigned imm 을 사용하는 덧셈이 되시겠다.

-unsigned 는 주로 주소를 표현할 때 사용된다. 그래서, 오버플로우를 경계하지 않는다.
-signed 계통 명령어들은 sign extention 을 사용하여 오버플로우에 대처한다.

-addiu 와 같은 명령을 할 때 주의해야 한다. imm이 주로 2의 보수로 표현되기 때문에, 
이런 경우는 sign extention 을 해 줘야 한다. 
===================
데이터 전송명령

MIPS 에서는 load 와 store 를 사용한다.
ㄴ>load 는 메인으로부터 가져올때
ㄴ>store 는 메인으로 write 할때


읽고 쓰는 단위는 32비트 word, 16비트 half-word, 8비트 byte 가 있다.

ㄴ>부동소수점 표현을 사용한 명령어가 따로 존재한다.
ㄴ>메모리의 주소를 생성하는 방법은 dispacement addressing mode 뿐이다.

lw : load word, 32비트를 읽어온다. 
ㄴ> lw $t0, 4($s3) 는 s3는 base address, 4는 offset 이라 한다.
ㄴ> 목표지점은 t0. t0 = s3 + 8 이 되겠다.


sw : store word, 32비트를 메인 메모리에 쓴다.
ㄴ> sw $t0, 8($s3) : source 는 t0 이다. destination 은 s3의 내용 + offset 이다.
ㄴ> offset 은 16비트 2의 보수이므로 2^15-1 ~ -2^15 가 offset 의 범위이다.


offset 을 사용하므로 역시 I format 을 사용한다. 

load word 의 예시

a= b+ *c 를 보자. 우리는 c로부터 값을 읽어와야 한다.
1. lw $t0 0(s2) : s2(=c) 안에는 주소가 담겨 있다. offset 0로 read되고, t0에 단느다
2. add $s0, $s1, $t0 : 불러온 값을 s0(=a) 에 저장한다.

*a = b+c 를 보자. 우리는 a가 가리키는 주소에 값을 전달해야 한다.
1. add $t0, $s1, $s2 : b+c 가 t0에 전달된다
2. sw $t0, 0($s0) : t0 가 s0에 offset 0 로 write 된다.


ㄴ>말하자면, int 가 아니라 int* 를 쓰고자 할때 사용하는 연산.
ㄴ>연산자 문법을 잘 숙지하도록 하자.

====================
array

배열의 이름은 포인터이다.

배열의 n번째 원소의 주소는, 
ㄴ> base address + n * 배열원소의 크기 이다.
ㄴ> 가령, 20번지에 저장된 int 배열 pow 의 5번째 원소는..
ㄴ> 20 + 5 * 4 = 40 이 되겠다. 
=====================
shift 명령어

int pow2[a] 가 있다.

a 를 사용하여 해당 주소의 위치를 나타내려면, a에 4를 곱한 것을 사용해야 한다.

sll = $t0, $s0, 2 ( shift left logical)
ㄴ> a는 $s0, pow 의 base 는 $s3 이라 하자.
ㄴ> $s0 값을 2 만큼 왼쪽으로 shift 하여 t0에 저장한다.
ㄴ> 곱 4 한것과 다른바가 없겠다.
ㄴ> 게다가 더 빠르다

ㄴ>add $t1, $t0, $s3
ㄴ>base 주소인 s3과, index address 인 t0를 더해 pow[a] 의 주소를 얻는다. 이것이 t1에 저장된다.
ㄴ>lw $v0, 0($t1) : pow[a] 의 주소 t1 에서 읽어다가 v0에 저장한다
=====================
*store floating point 뭔지 모르겠는데 61페이지에서 지울 것!

-Shift operation 
ㄴ>logical shift 는 항상 빈 자리에 0이 채워진다.
ㄴ>Arithmetic Shift right(shift) 의 경우, 옮겨지는 원소의 (0 or 1) 이 카피된다
ㄴ>어떻게 옮기느냐에 따라 빈자리에 채워지는 값 달라지는데 이거 파악할 것

-Conditional & unconditional branch 명령 다른 것 숙지할 것

-메인 메모리. 사이즈는 4바이트(모든 명령어가 4바이트로 처리)
ㄴ>명령어들의 주소 allignment 는 4의 배수로 시작.
ㄴ>명령어는 그래서 16비트짜리 word offset 을 사용한다
ㄴ>그래서 레지스터 끝에 00 이 들어간다.
ㄴ> 4바이트 단위로 사용하기 위함...

Offset 을 word offset 으로 다룰 것이다.?

바이트마다 가지고 있기 때문에 오른쪽 끝에 00을 붙인다. ?

-MIPS 비교구문
ㄴ>가령, 특정 범위를 설정한 if 문을 생각하자.
ㄴ>'sltiu' : set less then imm under


명령어를 워드 

