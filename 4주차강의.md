# Computer_structure
2021 1학기 컴퓨터구조론 내용정리

bne, beq : !=, == 여부에 따라서 특정 라인으로 점프

blt, ble : <, <= 여부에 따라서 특정 라인으로 점프 
ㄴ>pseudo

bgt, bge : >, >= 여부에 따라서 특정 라인으로 점프
ㄴ> pseudo

slt : < 여부에 따라서 destination 에 1 또는 0 전달


pseudo 명령들의 경우, psuedo 가 아닌 명령들을 조합하여 어셈블러가 새로 만든다.
ㄴ>마치 컴파일해주는것과 유사하다

move : $t0, $t1 : coply t1 to t0 이다.
ㄴ>psuedo

move 의 경우, 어셈블러가 add 와 $zero 를 사용하여 만들어낸다.

abs t0 t1 : t1의 절댓값을 t0 에 저장하는 pseudo 명령어이다.
ㄴ>이 경우 어셈블러가 해석하는 데에 레지스터가 하나 더 필요하다.

점프 명령은 j lable 과 같이 단순하게 사용한다.

이러한 명령은 26비트의 명령으로 이루어진다.
ㄴ>PC 의 좌측 4비트를 복사, 그리고 명령어의 우측 2비트를 00으로 만들어서 32비트 꼴을 맞춘다

branch 계통 명령어들은 I format 을 사용한다. 따라서 16비트 워드 범위를 벗어나는 위치의 명령어로는 점프할 수 없다.
ㄴ>이러한 경우, 어셈블러는 중간에 점프를 한번 더 하여 총 두번의 점프를 거치도록 명령어를 수정해 준다.

그럼에도 불구, 현재 수행하는 타깃 명령어와 j 명령어가 서로 256메가바이트 이상 떨어져 있어서는 안된다.

ㄴ>이런 상황을 위해 jr 명령어가 필요하다. 타깃 명령어의 주소를 jr $s0, s0의 위치로 한다

===============
어셈블리어의 루프

루프는 총 2개의 브랜치&점프 명령어를 통해 이루어진다.

1. bne 명령어 : C 프로그래머가 만든 루프조건문 내부의 내용을 레지스터 단위로 수행한다.
ㄴ>이것이 루프조건문을 만족시키지 못하면, Exit 으로 점프시킨다
2. j 명렁어 : 먼저 등장한 bne 명령어를 통화시켰으면, 루프 문 내부의 명령을 수행한다.
ㄴ> 그 이후, Loop 의 맨 처음으로 점프한다.
ㄴ>이때, j 명령어를 loop 문 진입 바로 전에 배치해서, loop 문 자체의 규모를 줄일 수 있다

아래가 일반적인 어셈블리 루프문의 양식이다

goto test
loop : body; #일반적인 연산이 여기서 진행된다
test : if (cond) #조건연산이 여기서 실행된다.
          goto loop; # 위의 test 조건연산문이 합격이면 loop 로 점프하여 연산한다

일반적인 이런 루프문 구성은 C에서 배운대로 하면 된다

=================
어셈블리어의 스위치

case 가 여러개일 경우 굉장히 느려진다.
ㄴ>점프를 위해 jr 명령어를 사용한다

===============
데이터와 명령어의 sign extention

signed no.는 32비트 확장하고 자 했을 때 부호를 sign extention 하게 된다.
unsigned no. 의 경우 무조건 zero extension 한다

산술연산 명령: sign ext.
logi 연산 명령 : zero ext.
load/store 명령: sign ext
Branch 명령 : sign ext


===================
양식 복습

R : op6 / rs5 / rt5 / rd5/ sa5 /ft6
ㄴ>연산을 위해 레지스터가 3개 필요한 연산의 경우

I : op6 / rs5 / rt5 / imm16
ㄴ> imm 데이터를 사용해야 하는 명령어의 경우들이다
ㄴ> 단순 산술연산 op 뒤에 i 가 붙는경우 역시 imm 을 사용해야 하기 때문에 I가 붙는다

ㄴ>branch 로 인해 명령어가 분기점을 만났을 때, imm  에 들어있는 offset 을 통해 얼마나 건너뛸지를 결정한다.
ㄴ>이때, 바이트 단위로 점프하기 때문에 점프해야하는 피트수 나누기 4 해주어야 한다

J : 

======================
호출 및 리턴하는 법을 


















