# Computer_structure
2021 1학기 컴퓨터구조론 내용정리

인도인 강사의 MIPS 수업

https://www.youtube.com/watch?v=u5Foo6mmW0I&list=PL5b07qlmA3P6zUdDf-o97ddfpvPFuNa5A

=============================
1강 - 레지스터

어셈블리어는 꽤 저급 언어이다. 여러가지를 할 수 있을 것.

레지스터 : 프로세스에 내장된 메모리들. 가장 빠르게 엑세스할 수 있는.

v : 씨스콜을 할때 v 에 수를 인가하여 사용할 함수를 선택할 것.
ㄴ>입력된 수에 따른 동작은 ? 를 선택하여 확인할 수 있었다.
a : 매개변수로 

Convention 을 따라야 한다. 
t : 정보 저장하는 곳. 프로세스들이 t의 값을 조정할 수 있다.
s : 마찬가지로 데이터를 저장하는 곳. 

k : 커널을 위한..

차차 알아갈 것이다.

=============================
2강

data segment : 미리 입력될 데이터들이 위치하는 자리이다. 
ㄴ>.asciiz : 큰 따옴표 내부에 입력되는 문자열이다.

text segment : 명령문들이 실질적으로 위치할 영역

syscall
1. v0 에 값을 전달하여 함수의 종류를 정의한다.
2. a0 는 syscall 에 필요한 매개변수를 담는 영역이다.
3. 때로는 a1 까지도 필요한 함수들이 존재한다.


syscall 4 : 문자열을 출력한다. 
ㄴ> char 하나를 출력할 때도 syscall 4를 사용한다.

=============================
3강


자료형 .byte : 글자 하나를 담을 수 있는 자료형이다.
ㄴ> .asciiz 와 같이 자료형의 하나이다. 데이터 세그먼트에 존재.

syscall 4 a0 가 가리키는 주소의 문자열을 출력한다.

============================
4강

.word : MIPS 의 가장 기본적인 단위라고 할 수 있겠다. 32비트 or 4바이트 단위이다.
ㄴ>명령어, 정보, 등등이 프로세서에 들어가는 최소의 단위라고 할 수 있다.
ㄴ>integer, 즉 정수 하나는 모두들 알다시피 4바이트 크기의 공간을 필요로 한다.

syscall 1 : a0 에 담긴 정수를 출력한다.
ㄴ> 주의!!! 다른 경우와는 다르게 주소가 아니라 정수를 필요로 한다.


# : 샾을 사용하여 주석을 작성할 수 있다.

==========================
5강 

.float : 부동소수점 표현, 소수점 6자리까지의 정확도를 가진다

syscall 2 : float 을 출력한다.

허나 이번엔, 일반적인 레지스터가 아닌 다른 곳으로부터 가져올 것이다.

Coproc1 이라는 영역의 f 레지스터들로부터 가져올 것이다. 가령 $f12
ㄴ>lwc1 $f12, PI
ㄴ>load word to coproc1 이다. Co-프로세서 이다.
ㄴ>이렇게 하면, coproc1 레지스터의 $f12 로부터 PI 의 float 을 가져온다.
ㄴ>

=========================
6강

.double : float 보다 크다.
ㄴ> 우리는 double 로서의 zero 를 가지고 있지 않다.
ㄴ>$zero 는 integer 0 이다.
ㄴ>따라서, double 연산을 원한다면 데이터 세그먼트에 double 형의 zero 를 선언해둘 필요가 있다.

ldc1 : double 한개를 coproc1 레지스터로 가져온다.
ㄴ>lwc1 에서는 word 였지만, double 은 64비트 자료형이기 때문에 따로 취급된다
ㄴ>레지스터는 마찬가지로 
ㄴ>연산도 add.d 와 같이 .d 를 사용한다.

!!!!주의!!!!
double 형 자료를 다룰 때에는, f 레지스터들 중 짝수 번호의 레지스터만 사용하라.

============================
7강 - 정수더하기

1. lw 를 사용하여, 32비트 word 크기의 자료를 레지스터에 담는다.
lw $t0, number1($zero)
ㄴ>위와 같은 동작이 가능하다. number1 주소에 있는 word 가 t0 으로 로드된다.

2. add 명령어 실행


syscall 1 : a0 에 담겨있는 값을 출력한다.
ㄴ>자료 이동은 add zero 와 같은 방법을 사용한다. 

=============================
8강 - 정수빼기

정수더하기와 과정들이 매우 유사하다.

move $a0, $t0
ㄴ>a0 로 t0 의 자료를 옮기는 pseudo code 이다.

==============================
9강 - 정수곱하기

여러가지 방법이 있다.

addi $t0, $t1, 4 : 레지스터의 값에 상수를 더하여 리턴한다.

mul $a0, $t0, $t1 : t0 곱하기 t1 이 a0 에 입력된다.
=================================
10강 - 정수곱하기 2

addi 로 t 레지스터들에 값들을 담아 시작한다.

hi & lo : 레지스터들중에 hi 와 lo 가 있다.

mult $t0, $t1 : t0 곱하기 t1 이 hi 와 lo 레지스터에 저장된다.


!!!주의!!!
이 방법은 단순 mul 보다 큰 결괏값을 저장할 수 있다. 두 레지스터에 결과가 나누어 저장되기 때문이다.

mflo $s0 : lo 레지스터의 내용을 s0 에 가져온다.
ㄴ>만약 hi 까지 침범할 정도로 곱셈의 결과가 크다면, lo 레지스터의 내용만 사용하는 것이 좋지 못할 지도   

mfhi $s1 : hi 레지스터의 내용을 s1 에 가져온다.

==================================
11강 - 정수곱하기 3

sll $t0, $s0, n: shift left logical 
ㄴ>s0 의 값에 2의 n 승 한 만큼을 t0 에 저장한다.
ㄴ>srl 도 존재한다..

=================================
12강 - 정수나누기 1

div $s0, $t0, $t1 : s0 에 t0/t1 이 저장된다.

ㄴ>과연 이것은 정수나누기 정수 계산일까? 아마도 그럴 것이다.
ㄴ>하지만 double 끼리라면 어떨까?

================================
13강 - 정수나누기 2

div 에는 여러가지 유형의 오버로딩이 되어있다.

div $s0, $t0, 10 : 10으로 나눈다. imm 을 자연스럽게 사용할 수 있다.
div $t0, $t1
ㄴ>몫은 lo 에 저장된다
ㄴ>나머지는 hi 에 저장된다.
ㄴ>mflo/mfhi 를 통해 데이터를 가져다 쓰면 되겠다.




