# Computer_structure
2021 1학기 컴퓨터구조론 내용정리

인도인 강사의 MIPS 수업

https://www.youtube.com/watch?v=u5Foo6mmW0I&list=PL5b07qlmA3P6zUdDf-o97ddfpvPFuNa5A

=============================
1강 - 레지스터

어셈블리어는 꽤 저급 언어이다. 여러가지를 할 수 있을 것.

레지스터 : 프로세스에 내장된 메모리들. 가장 빠르게 엑세스할 수 있는.

v : 씨스콜을 할때 v 에 수를 인가하여 사용할 함수를 선택할 것.
ㄴ>입력된 수에 따른 동작은 ? 를 선택하여 확인할 수 있었다.
a : 매개변수로 

Convention 을 따라야 한다. 
t : 정보 저장하는 곳. 프로세스들이 t의 값을 조정할 수 있다.
s : 마찬가지로 데이터를 저장하는 곳. 

k : 커널을 위한..

차차 알아갈 것이다.

=============================
2강

data segment : 미리 입력될 데이터들이 위치하는 자리이다. 
ㄴ>.asciiz : 큰 따옴표 내부에 입력되는 문자열이다.

text segment : 명령문들이 실질적으로 위치할 영역

syscall
1. v0 에 값을 전달하여 함수의 종류를 정의한다.
2. a0 는 syscall 에 필요한 매개변수를 담는 영역이다.
3. 때로는 a1 까지도 필요한 함수들이 존재한다.


syscall 4 : 문자열을 출력한다. 
ㄴ> char 하나를 출력할 때도 syscall 4를 사용한다.

=============================
3강


자료형 .byte : 글자 하나를 담을 수 있는 자료형이다.
ㄴ> .asciiz 와 같이 자료형의 하나이다. 데이터 세그먼트에 존재.

syscall 4 a0 가 가리키는 주소의 문자열을 출력한다.

============================
4강

.word : MIPS 의 가장 기본적인 단위라고 할 수 있겠다. 32비트 or 4바이트 단위이다.
ㄴ>명령어, 정보, 등등이 프로세서에 들어가는 최소의 단위라고 할 수 있다.
ㄴ>integer, 즉 정수 하나는 모두들 알다시피 4바이트 크기의 공간을 필요로 한다.

syscall 1 : a0 에 담긴 정수를 출력한다.
ㄴ> 주의!!! 다른 경우와는 다르게 주소가 아니라 정수를 필요로 한다.


# : 샾을 사용하여 주석을 작성할 수 있다.

==========================
5강 

.float : 부동소수점 표현, 소수점 6자리까지의 정확도를 가진다

syscall 2 : float 을 출력한다.

허나 이번엔, 일반적인 레지스터가 아닌 다른 곳으로부터 가져올 것이다.

Coproc1 이라는 영역의 f 레지스터들로부터 가져올 것이다. 가령 $f12
ㄴ>lwc1 $f12, PI
ㄴ>load word to coproc1 이다. Co-프로세서 이다.
ㄴ>이렇게 하면, coproc1 레지스터의 $f12 로부터 PI 의 float 을 가져온다.
ㄴ>

=========================
6강

.double : float 보다 크다.
ㄴ> 우리는 double 로서의 zero 를 가지고 있지 않다.
ㄴ>$zero 는 integer 0 이다.
ㄴ>따라서, double 연산을 원한다면 데이터 세그먼트에 double 형의 zero 를 선언해둘 필요가 있다.

ldc1 : double 한개를 coproc1 레지스터로 가져온다.
ㄴ>lwc1 에서는 word 였지만, double 은 64비트 자료형이기 때문에 따로 취급된다
ㄴ>레지스터는 마찬가지로 
ㄴ>연산도 add.d 와 같이 .d 를 사용한다.

!!!!주의!!!!
double 형 자료를 다룰 때에는, f 레지스터들 중 짝수 번호의 레지스터만 사용하라.

============================
7강 - 정수더하기

1. lw 를 사용하여, 32비트 word 크기의 자료를 레지스터에 담는다.
lw $t0, number1($zero)
ㄴ>위와 같은 동작이 가능하다. number1 주소에 있는 word 가 t0 으로 로드된다.

2. add 명령어 실행


syscall 1 : a0 에 담겨있는 값을 출력한다.
ㄴ>자료 이동은 add zero 와 같은 방법을 사용한다. 

=============================
8강 - 정수빼기

정수더하기와 과정들이 매우 유사하다.

move $a0, $t0
ㄴ>a0 로 t0 의 자료를 옮기는 pseudo code 이다.

==============================
9강 - 정수곱하기

여러가지 방법이 있다.

addi $t0, $t1, 4 : 레지스터의 값에 상수를 더하여 리턴한다.

mul $a0, $t0, $t1 : t0 곱하기 t1 이 a0 에 입력된다.
=================================
10강 - 정수곱하기 2

addi 로 t 레지스터들에 값들을 담아 시작한다.

hi & lo : 레지스터들중에 hi 와 lo 가 있다.

mult $t0, $t1 : t0 곱하기 t1 이 hi 와 lo 레지스터에 저장된다.


!!!주의!!!
이 방법은 단순 mul 보다 큰 결괏값을 저장할 수 있다. 두 레지스터에 결과가 나누어 저장되기 때문이다.

mflo $s0 : lo 레지스터의 내용을 s0 에 가져온다.
ㄴ>만약 hi 까지 침범할 정도로 곱셈의 결과가 크다면, lo 레지스터의 내용만 사용하는 것이 좋지 못할 지도   

mfhi $s1 : hi 레지스터의 내용을 s1 에 가져온다.

==================================
11강 - 정수곱하기 3

sll $t0, $s0, n: shift left logical 
ㄴ>s0 의 값에 2의 n 승 한 만큼을 t0 에 저장한다.
ㄴ>srl 도 존재한다..

=================================
12강 - 정수나누기 1

div $s0, $t0, $t1 : s0 에 t0/t1 이 저장된다.

ㄴ>과연 이것은 정수나누기 정수 계산일까? 아마도 그럴 것이다.
ㄴ>하지만 double 끼리라면 어떨까?

================================
13강 - 정수나누기 2

div 에는 여러가지 유형의 오버로딩이 되어있다.

div $s0, $t0, 10 : 10으로 나눈다. imm 을 자연스럽게 사용할 수 있다.
div $t0, $t1
ㄴ>몫은 lo 에 저장된다
ㄴ>나머지는 hi 에 저장된다.
ㄴ>mflo/mfhi 를 통해 데이터를 가져다 쓰면 되겠다.

================================
14강 함수 입문

함수란, 재사용 가능한, 명령문의 집합이라고 할 수 있겠다.

함수를 사용한다는 것은 함수를 호출한다는 것이다.

MIPS 에서는, 이것을 Procedure 라고 부른다.

main 은 너의 프로그램의 메인 procedure 라고 할 수 있다.


레이블 : procedure 는 lable 로 시작한다. 

 jr $ra : procedure이 완료되고 나서, 함수의 호출지점으로 다시 돌아가는 명령이다.]

syscall 10 : 프로그램을 종료시키는 syscall 이다. 
ㄴ>이것이 없으면, main 하단의 procedure 들이 jr 명령으로 인해 무한루프 하게 될 것이다.
ㄴ>그러므로 main 의 마지막에는 반드시 syscall 10 이 위치해야만 한다.


jal name : name 이라는 이름의 lable 로 점프한다.
ㄴ>이때 $ra 는 보존되며, name 에서 jr $ra 했을 때 main 함수의 원래 자리로 돌아올 수 있게 한다.


================================
15강

함수에는 매개변수가 전달되어야 하기 마련이다.

전통적으로, a 계통 레지스터들이 사용된다.(0~3 총 4레지스터)

그렇다면, 반환값은 어디에 반환될 것인가

전통적으로 v 계통 레지스터들이 사용된다 (주로 v1)


1. 함수를 호출할 때 변수를 패스하고 싶다면 a 계통 레지스터를 사용하라
2. 함수가 값을 반환할 때에는 v 계통 레지스터를 사용하라.

===============================
16강

s 레지스터를 스택에 저장하는 방법.

함수를 호출한다. 함수가 t 레지스터를 조작한다.

전통은 이러하다 s 레지스터들은 피호출함수에서는 조작되어선 아니된다.
ㄴ>그래서, s 레지스터를 사용할 요량이라면, 원래 s 레지스터에 들어있던 값을 stack 에 원천보존해놓을 수 있어야 하겠다.

$sp : 스택 포인터이다. 
"스택은 거꾸로 자란다"
ㄴ> 만약 sp 라는 스택 영역에 word 데이터를 담고 싶으면, addi $sp, $sp, -4 하여 4바이트를 내려 주어야 한다
ㄴ> 피호출함수에서 s 레지스터를 사용하고자 한다면, s 의 원본 데이터를 스택에 우선 담고 시작한다.
ㄴ> 그리고 jr ra 로 다시 돌아가기 전에 s 의 값이 복구되는 것이 건전하다. 전통이다. 

정리하자면 다음과 같다

0. s 레지스터를 사용하고 싶다
1. 사용할 데이터의 크기만큼 sb 의 주소값을 내린다 (addi ...-4)
2. 내린 sb 의 위치에 정해진 크기만큼의 데이터를 할당한다 (sw ... 0($sb))
3. s 레지스터의 사용이 끝난 후 해당 위치의 데이터를 돌려 받는다(lw ... 0($sb))
4. 다시 sb 의 주소값을 올린다 (addi ... 4)


t 레지스터의 경우 함수의 시작과 종료의 값이 다른 것이 상관이 없다고 하겠다.
s 레지스터는 caller saved, t 레지스터는 callee saved.

==============================
17강 - 함수 재사용

어떤 procedure 를 main 뿐만 아니라 여러 함수에서 재사용하고 싶다고 하자.

어떤 procedure 가 또다른 procedure 를 사용할 때 이것을 Nesting Procedure 라고 한다.

$ra 는 main 내부의 위치를 기억한다. 따라서 , Nesting 의 경우에도 주소를 기억해야 한다.
ㄴ>스택을 사용하여 저장할 것이다.

jal 의 의미 
1. jal 하면, 지금 이 위치를 $ra 가 기억한다.
2. Nesting Procedure 가 실행된다.
3. 실행의 끝에 ra 의 위치로 다시 돌아온다

따라서, 우리는 다음과 같은 방법을 취한다.

1. main 으로 돌아갈 $ra 를 가지고 calee procedure 가 시작된다
2. 현재 ra 를 스택에 보관한다 (sw $ra 0($sb)를 사용하여)
3. jal 명령을 실시한다 -> ra가 지금 막 점프한 위치로 변경된다
4. Nesting Procedure 가 실행된 뒤 jr ra 로 다시 돌아온다
5. 다시 돌아온 procedure 에서 lw 를 통해 ra 를 복구한다
6. jr ra 하면 main 으로 돌아갈 수 있다

=================
18강 - 정수입력

syscall 5 : int 를 입력받는다. 입력받은 정수는 $v0 에 저장된다.

ㄴ>보통, 이것은 나중에 조작되기 위해 다른 레지스터 - 가령 $t0 로 옮겨진다.

===================
19강 - float 입력

float 을 사용하는 프로그램에서는, data segment 에 0.0 이라는 데이터를 따로 저장해 두는것이 신상에 이롭다.

lwc1 $f12, zero_float : coproc 1 의 레지스터로 가져온다. zero_float 을.

syscall 6 : $f0 레지스터에 값을 입력받는다. 

syscall 2 : $f12 레지스터에 있는 double 을 출력한다

ㄴ>입출력에 어떤 레지스터가 사용되는 지 숙지할 필요가 있다.

======================
20강 - double 입력

double 은 두개의 f 레지스터를 필요로 한다. (64비트 자료형이기 때문이다)


syscall 7 : f0 에 사용자가 입력한 double 자료형을 저장한다.

syscall 3 : $f12 레지스터에 저장되어 있는 double 을 출력한다.

========================
21 강 - 문자열 입력

.space n : 임의의 공간을 크기 n 만큼 할당한다. 
ㄴ>레이블에는 공간의 주소가 할당된다.
ㄴ>버퍼라는 공간은 어떻게 활용해야 하는걸까?

syscall 8 : $a0 가 가리키는 주소에, size는 $a1 만큼의 자료를 저장한다. 

ㄴ>Userinput 이라는 n 크기 .space 에 사용자의 입력이 들어갔다.
ㄴ>그리고, a0 는 그 주소를 가리키고 있어야 한다.
ㄴ>그리고,  syscall 4 
ㄴ>사용자가 입력한 문자열이 출력된다.

==========================
27강 - 배열

배열은 하나의 데이터의 목록이다.

이번에도 .space 를 활용할 것이다 다만,
ㄴ>int 배열을 사용하고자 한다면 * 4 해야 한다는 것을 인지
ㄴ>char 배열 = 문자열 의 경우 * 1


우리가 space 를 사용하여 할당한 공간은 random excess memory 와 같다.
ㄴ>이것을 어떻게 사용할 것인가.

1. t0 를 index 로 사용하도록 하자
2. sw 명령을 사용하여, s0,s1,s2 에 저장한 int 를 저장하자.
ㄴ>sw $s0, myIntarray($t0)
ㄴ>이렇게 하면, 배열의 index t0 에 s0에 담긴 int 가 저장될 것이다.
3. t0 를 업데이트하여 다른 index 에 접촉한다

===========================
28강 - 반복문을 사용한 배열조작

반복문 레이블, 그리고 그것의 exit 레이블을 설정한다. 
ㄴ>bracn 레이블 하여 조작할 것이다.

1. 우리는 현재, myIntArray 에 3개의 정수를 담아두고 있다.
ㄴ>각 자료는 myIntarray의 4바이트마다 저장되어 있다
2. 그리고, t0 라는 index 변수를 사용하여 억세스할 것이다.
ㄴ>0, 4, 8 index 를 사용하여 자료에 억세스할 수 있다.

따라서,
1. 반복문은 1회차마다 t 를 0 에서 시작하여 +4 씩 증가시킨다.
2. t = 12 가 되고 나면 반복이 종료되어야 한다. 따라서 t를 가장 먼저 검사하고 반복이 시작될 것이다
3. 자료형마다 인덱스를 다루는 방법은 달라질 것.


반복문의 문법

1. loop 레이블 하나와 exit 레이블 하나가 필요하다.
2. 1 loop 가 끝나고 나면, j loop 로 점프한다.
3. 적절한 시점에 branch 계통 조건문 명령어를 통해 exit 을 통해 나가도록 한다.
4. loop 가 진행되면서, 검사시점 이후 조건변수 역시 업데이트될 수 있도록 해야 한다.

=============================
29강 - 배열 초기화 장치

배열이 디폴트한 값을 가지고 싶을 때 어떻게 하면 좋을까.


myArray .word 100:3 
ㄴ>100 으로 초기화된 word 3개짜리 공간이 myArray 에 생긴다.
ㄴ>차지하는 공간은 프로그래머가 직접 계산해야 한다. 위의 경우는 4바이트 * 3

===============================
33강 - 재귀

메모리는 이렇게 구성된다.

1. 아래로 자라는 스택
2. 위로 자라는 heap
3. heap 아래의 데이터와 텍스트 세그먼트. 

동적 메모리는 항상 heap 영역을 사용하게 된다.
ㄴ>지우는 것을 잊지 말아야 하는 그 영역이 바로 heap 영역이다


함수가 본인 스스로를 호출하는 것이 재귀이다. 

팩토리얼 재귀를 보자.
1. n =0 이면 1 반환
2. else, n * factorial(n-1) 반환

보통의 반복은 반복 횟수가 시작 시점에서 정해져 있을 때 유용하다.
재귀 반복문의 경우, 그것이 파악하기 어려울 때 유용하다.

 함수 호출 명령은 스택에 쌓인다. 
 1. 당연히 가장 높은 곳(=가장 초기의, 처음의) 자리에는 main 이 위치한다
 2. 그다음 재귀함수가 호출되면, 아래로 술술 자란다.
 3. 재귀가 기저에 도달하면, 순서대로 자란 스택이 최상위까지 pop 된다. 

이러한 양식이 MIPS 에선 어떻게 구현될까.

====구현===
.global : 함수 이름을 여기에 선언한다. 우측에 레이블 이름을 적으면 된다.

레이블 하위에 이제 함수를 정의하면 된다.

...k 번째 재귀가 호출되었다.

1. 호출이 되었으니 우선 공간부터 확보한다.
ㄴ> addi sp -8 한다.
ㄴ> 4바이트에 ra 와 s0 를 저장하고 본다.

2. 매개변수 a0 가 베이스 케이스인지 검사하자.
ㄴ> 맞는 경우, end 로 점프한다.

3. 아닌 경우, s0 와 $ra 를 갱신해야 한다.
ㄴ> 이번 회차의 값을 s0 에 저장한다.
ㄴ> jal 을 사용하면 $ra 는 알아서 업데이트된다.

4. 다음 회차를 호출한다.
ㄴ> 매개변수를 적절히 조절한 뒤 축소된 문제를 호출하면 된다.


a. 탈출한 경우
ㄴ> 스택을 바닥에서부터 주워담아야 한다.
ㄴ> 현재 $sp 가 바닥이라는 확신이 우리에겐 있다. $ra 는 스택의 다음 순서로 갈 단서를 가지고 있다.
ㄴ> 최상위 $ra 자리는 main 으로 돌아간다. 문제없다.
ㄴ> 그러니, 스택 공간에서 s0 를 로드해서 출력 v0 에 적절히 조정한다.
ㄴ> $ra 를 잘 챙겨서, jr $ra 한다./







