# Computer_structure
2021 1학기 컴퓨터구조론 내용정리


컴퓨터는 반도체와 컴퓨터구조 설계능력의 발달과 함께 성능향상 되어왔다.

그래서, 어셈블리어가 아닌 유닉스, 리눅스와 같은 표준화된 OS가 개발되게 되었다.

이러한 발달은 RISC (컴퓨터 구조론 개념)의 발달이 크게 작용하였다.


따라서, 컴퓨터가 과거에는 사용될 수 없었던 분야에서 사용되고 있다.

이제, 어디에도, 우리가 찾아볼 수 있는, 그러한 요소가 되었다.


크게 세개.
1. 개인용 컴퓨터 PC
ㄴ> cost/performence 가 굉장히 중요한 영역. 일반적 용도.
2. 서버컴퓨터
ㄴ>과거의 대형컴퓨터. 성능이 월등히 높다.
ㄴ>신뢰성이 아주 중요하다. 성능 범위가 넓다.
3. 슈퍼컴퓨터.
ㄴ>주로 과학이나 공학의 복잡한 연산에 사용된다.
ㄴ>최고의 성능을 보이지만 시장의 크기가 작다.
4. 임베디드
ㄴ>시스템의 한 부속품이다. 
ㄴ>가격, 전력, 성능에 대한 기준이 엄격하다. 

ㄴ>활용 영역에 따라서 제한이 다양하다. 가령, tv셋톱은 성능의 요구사항이 낮다.

5. POST PC 시대
ㄴ>PMD(무선 모바일장비)와 클라우드 컴퓨터 등의 서비스


===============

우리는 이 수업에서, 소프트웨어가 어떻게 하드웨어를 동작시키는지 배운다.

프로그램의 성능이 무엇인지, 성능과 출력 효율을 증가시킬 수 있는 기술엔 무엇이 있는지.

싱글코어에서 멀티코어로 시대가 넘어가게 된 이유가 무엇인지.

컴퓨터의 성능을 향상시킬 수 있는 위대한 아이디어들은 무엇이 있었는지.

==============

다양한 종류와 다양한 활용도, 다양한 생산자가 존재한다. 기술마저 다양하다.

그렇다면, 어떻게 컴퓨터 시스템의 동작을 배우는 것이 좋을까.

우선, 일반적인 원리를 배울 것이다.

그리고, 그원리가 어떻게 실제 시스템에 적용이 되고 동작하는지를 배울 것이다.

=============
하드웨어와 소프트웨어 전부 성능에 영향을 끼친다.

알고리즘. 중요하지만 이 과목의 주제는 아니다.

프로그래밍 언어, 컴파일러, 구조 역시 영향을 준다. - chpt 2&3

프로세서와 메모리 시스템 - chpt 4,5,6

I/O 시스템 마찬가지...

===============
이 수업에서는 아이디어 8개를 배운다.

각 아이디어들의 개념과 그 아이디어의 상징적인 응용도 같이 배울 것이다.

===============
컴퓨터가 동작하는 배경에는...

기저에 하드웨어, 중간에는 시스템 소프트웨어, 가장 바깥에는 응용 소프트웨어가 있다.

시스템 소프트웨어는 OS 와 컴파일러 따위가 있다. OS 는 여러 프로그램이 하드웨어를 사용할 수 있도록 조절/할당한다. 항상 실행되고 있다.

컴파일러는, 프로그래밍 언어를 어셈블리어로, 어셈블리어는 기계어로 번역된다.

자연어에 가까운 프로그래밍 언어를 사용하면, 의도하는 목적에 가깝게 접근할 수 있다.

하드웨어와 독립적으로 프로그래밍할 수 있다. 더 최적화할 수 있다.

그럼에도 불구, 우리는 이 시간에, 어셈블리 프로그래밍을 애써 배울 것이다.
-컴퓨터의 동작을 이해하는 핵심이기 때문이다.
-프로그램의 버그를 분석하는 데 어샘블리어가 사용될 수 있다.
-비효율성 역시 어셈블리어를 통해 분석될 수있다.
-시스템 소프트웨어 수준으로 내려가서는 어셈블리어가 여전히 유용하다.

=================
고전적인 컴퓨터 장치들이 있다.

컨트롤 : 뇌

데이터페스 : 근육

메모리 : 프로그램과 데이터가 저장되는 위치.

I/O : 데이터의 출력이 일어나는  위치.

================
사람 손의 커패시티, 그리고 압력을 사용하는 경우가 있다.

공장/병원에서는 내구성이 중요하기 때문에 후자가 사용되고,

소비자 용으로는 멀티터치가 가능하다는 점 때문에 전자가 사용된다.


LCD는 가장 일반적으로 사용되는 출력장치이다.

프레임 버퍼에 저장된 데이터가 픽셀을 통해 LCD 에 나타난다.

디스플레이는 픽셀의 메트릭스다.

=================
ISA : instruction set 구조

그냥 아키텍쳐 라고도 한다.

하드웨어로 소프웨어의 의사가 전달되는 구조를 이야기한다.

어셈블리 프로그래머의 영역이다. 명령어, 레지스터, I/O 등의 정보를 모두 표현한다.


같은 구조가 여러가지 방법으로 구현될 수 있다. 

=====================
Decimal prefix & Binary prefix

전자는 KB = 10^3 이고, 후자는 KB = 2^10 이다.
ㄴ> 보통 후자는 KiB 라고 표기하기는 한다.
ㄴ>키비바이트 라고 읽는다.

메인 메모리에서는 주로 바이너리 prefix 계통을 사용한다.

실제로 구현할 수 있는 범위가 있기 때문이다.

====================(중요)
yield : 수율

IC 생산 과정에서 오차율을 제외한 생산 효율을 이야기한다.

웨이퍼 위에 많은 다이가 생산되는 식이다.

(중요) 다이 1개의 갸격 = 웨이퍼 1개의 가격 / (웨이퍼 1개 당 다이의 개수 * 수율
ㄴ>수율 : 1/(1+면적당 소실 * 다이의 면적)^N  (*N = process-complexity factor)


===================
무어의 법칙

거의 50년간 지켜진 법칙

단위면적당 트랜지스터의 개수가 2년마다 두배씩 늘어나는 것.

최근에는 그 속도를 잃었다.

===================
성능의 정의

비행기의 성능상 우위는 정의하기가 쉽지 않다.

속도? 여객기의 크기? 어떤 관점에서 바라볼 것인지 쉽지 않다.

컴퓨터에 대한 것도 마찬가지이다.


소비자에게 선택을 받기 위해 팔리는 기계도 마찬가지이다.


마지막으로 우리의 요점인, 컴퓨터 디자인 방법론 역시 마찬가지이다.

어떤 관점에서 비교할 것인지 그 관점과 비교를 위한 매트릭스가 필요하다.

이런 목적을 달성하기 위해, 상대적 중요도를 점수를 매길 수 있어야 한다. 

==================
성능의 관점

Response time : 작업의 시작과 끝에 걸리는 시간
ㄴ>개인 사용자에게 중요

Throughput : 단위시간당 수행능력
ㄴ>데이터센터 등 대규모에 도움이 된다

프로세서를 업그레이드 : 둘다 향상된다.
프로세서의 개수 증가 :  대체로 Throughput 만 향상된다.

==================(중요)
실행시간 

유저 프로그램을 수행하는데 걸리는 시간, OS 를 수행하는데 걸리는 시간 두 가지가 있다.

CPU 퍼포먼스가 전자, 시스템 퍼포먼스가 후자이다.

퍼포먼스 = 1/수행시간 이다.


Response time 이 decrease 하는 것은 Throughput 을 늘린다.
ㄴ>하지만 그 역은 성립하지 않는다.

=================(중요)
클럭

컴퓨터의 연산은 연산 -> 상태 적용 -> 연산 의 과정을 거친다.

이때, 연산을 시작하여 상태의 적용까지 걸리는 시간을 clock cycle time 이라고 한다.

clock rate : clock cycle time 의 역, 초당 cycle 의 횟수이다. 단위는 cycle/time -> 헤르츠 가 되겠다.


CPU 수행시간 = 프로그램 수행에 필요한 Cycle 횟수 / clock rate


수행시간을 줄이고 싶다면?
1. Cycle rate 를 늘린다. 즉 초당 사이클 횟수를 늘린다.
2. cycle 횟수 자체를 늘린다.
ㄴ>보통 둘 사이에서 조율을 해야 하는 상황이 온다.

예제)
2GHz 클럭(=clock rate) 를 가지는 컴퓨터가 수행시간에 10초가 필요한 프로그램이 있다.
6초 안에 이 프로그램을 완료하려면 clock rate 가 얼마나 필요한가. ?

1. Required clock cycles = 2*10^9 * 10
2. B's clock cycles = 1.2 * 20 * 10^9
ㄴ> 2를 6으로 나눈다.

===================
CPU clock cycles

= IC(instruction count) * CPI(clock per instruction)

ㄴ>CPI 는 평균치이다. 왜냐하면 instruction(=작업) 당 사이클 횟수는 다르기 때문, 

*CPI 는 다양한 작업들의 종류를 묶어서 따로 계산해야 한다.
*그래서, CPI 는 수열의 형태로 계산된다. 

===================
수행시간 - 결론

결국 그래서, 컴퓨터의 수행시간은

IC * CPI * clock cycle time (사이클 1개당 소요되는 시간) 이다.

ㄴ>CPI 는 모든 계산들의 평균치를 생각해야 함을 잊지 마라.
*가령, 작업들의 CPI 와 그 빈도수가 주어질 수 있다.



-------------------
줌강의

컴퓨터 구조는 ISA 부터 시작한다.

베릴로그를 사용한 설계를 진행할 것인데, 툴은 자일링스 비바도 사용할 것.

어샘블리어를 우리가 배우는 이유는, 하드웨어를 좀 더 잘 이해하기 위함이다.

기계어를 실제로 수행해 봐야 버그의 근거를 찾고 고칠 수 있는 것이다.


여러가지 형태로 같은 ISA 를 다르게 구현할 수 있다.

같은 ISA 를 사용한 이들을 같은 패밀리라고 한다. 

어떤 프로그램이 ABI 를 만족하면 프로그램이 PC 와 노트북 둘다 실행될 수있다.
ㄴ>Application binary interface

Response time 은 PC에서 중요하다

Throughput 은 데이터센터같은 곳에서 중요하다. (여러개를 한번에 실행)


SPEC 웹사이트가 있다. 거기에 공통적으로 컴퓨터들의 성능이 측정되어 올라온다.

(중요)성능요소를 결정하는 수식이 있다. PPT 45페이지 인근부터.


======
